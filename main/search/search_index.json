{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":""},{"location":"#getting-started-with-pret","title":"Getting started with Pret","text":"<p>Pret is a library for building full-stack reactive user interfaces in Python, using React as a rendering engine.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pret pret-joy\n</code></pre> <p>To use it with Jupyter, if you install the library in a custom environment (conda, venv, or other), you will likely need to tell Jupyter where to find the front-end files. You can do this by running the following command (only once):</p> <pre><code>pret update-jupyter-config --apply\n</code></pre>"},{"location":"#features","title":"Features","text":"<ul> <li>Python, only Python: pret is written in Python: you can write your both your UI and server actions Python. No need to learn a new language.</li> <li>Client-side rendering: unlike other Python UI frameworks, pret runs primarily in the browser. This enables a fast response time to user actions (like hover events), and a better user experience under degraded network conditions.</li> <li>Built on React: pret uses React as a rendering engine, and benefits from its ecosystem.</li> <li>Reactive: unlike other solutions like ipywidgets, pret is reactive. Only the parts of the UI that need to be updated are re-rendered.</li> <li>State management: in addition to React's local state management (i.e. <code>use_state</code>), pret provides a global and modular state management solution that is synchronized both between components, and between the client and the server.</li> <li>Modular: pret is designed to be modular. You can easily create your own components, and reuse them in other pret-based projects.</li> <li>Integrated with Jupyter: pret components can be used in Jupyter notebooks, as well as in standalone web applications.</li> <li>Remote execution: pret can call and use the result of Python functions on the server from the browser</li> </ul>"},{"location":"#use-it-in-a-notebook","title":"Use it in a notebook","text":"<p>Let's write a simple todo app that should:</p> <ul> <li>display a list of todos, that can be checked as done</li> <li>display the number remaining todos</li> <li>change the font to bold as a todo is hovered</li> <li>allow editing the todo list directly in Python</li> </ul> <p>Copy and paste the following code in a notebook:</p> <pre><code>from pret import component, create_store, run, use_state, use_store_snapshot\nfrom pret.ui.joy import Checkbox, Input, Stack, Typography\n\nstate = create_store(\n  {\n    \"faire \u00e0 manger\": True,\n    \"faire la vaisselle\": False,\n  },\n  sync=True,\n)\n\n\n@component\ndef TodoApp():\n  todos = use_store_snapshot(state)\n  typed, set_typed = use_state(\"\")\n  num_remaining = sum(not ok for ok in todos.values())\n  plural = \"s\" if num_remaining &gt; 1 else \"\"\n\n  def on_key_down(event):\n    if event.key == \"Enter\":\n      state[typed] = False\n      set_typed(\"\")\n\n  return Stack(\n    *(\n      Checkbox(\n        label=todo,\n        checked=ok,\n        on_change=lambda e, t=todo: state.update({t: e.target.checked}),\n      )\n      for todo, ok in todos.items()\n    ),\n    Input(\n      value=typed,\n      on_change=lambda event: set_typed(event.target.value),\n      on_key_down=on_key_down,\n      placeholder=\"Add a todo\",\n    ),\n    Typography(\n      f\"Number of unfinished todo{plural}: {num_remaining}\",\n      sx={\"minWidth\": \"230px\"},  # just to avoid jittering when it's centered\n    ),\n    spacing=2,\n    sx={\"m\": 1},\n  )\n\n\nTodoApp()\n</code></pre> <p>In comparison, the closest alternative using ipywidgets looks like the following snippet:</p> IPyWidget's implementation <pre><code>import ipywidgets as widgets\n\nstate = {\n    \"faire \u00e0 manger\": True,\n    \"faire la vaisselle\": False,\n}\n\n\nclass IPWTodoApp:\n    def __init__(self):\n        self.box = widgets.VBox()\n        self.render()\n\n    def _repr_mimebundle_(self, *args, **kwargs):\n        return self.box._repr_mimebundle_(*args, **kwargs)\n\n    def render(self, *args, **kwargs):\n        num_remaining = sum([not checked for _, checked in state.items()])\n        plural = \"s\" if num_remaining &gt; 1 else \"\"\n\n        def on_input_submit(sender):\n            state[input_widget.value] = False\n            self.render()\n\n        def create_todo_item(todo, checked):\n            def update_todo_status(*args, **kwargs):\n                state[todo] = checkbox.value\n                self.render()\n\n            checkbox = widgets.Checkbox(\n                value=checked,\n                description=todo,\n                disabled=False,\n                indent=False,\n            )\n            checkbox.observe(update_todo_status, names=\"value\")\n            return checkbox\n\n        input_widget = widgets.Text(\n            placeholder=\"Add a todo\",\n            description=\"\",\n            disabled=False,\n        )\n        input_widget.on_submit(on_input_submit)\n\n        self.box.children = [\n            *(create_todo_item(todo, checked) for todo, checked in state.items()),\n            input_widget,\n            widgets.Label(value=f\"Number of unfinished todo{plural}: {num_remaining}\"),\n        ]\n\n\nIPWTodoApp()\n</code></pre> <p>You also lose some features:</p> <ul> <li>the app stops working if the server shuts down</li> <li>hover events cannot be listened to</li> <li>no React dom diffing: the app must either be re-rendered entirely (as in the example),   or you must determine specifically which field of which widget to update</li> </ul>"},{"location":"#use-it-in-a-standalone-app","title":"Use it in a standalone app","text":"<p>You can also use pret to build standalone web applications. Copy the above code in a file named <code>app.py</code>, and change the last line to</p> <pre><code>if __name__ == \"__main__\":\n    run(TodoApp)\n</code></pre> <p>Then, run the following command, and voil\u00e0 !</p> <pre><code>python app.py\n</code></pre>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Here are step-by-step guides to get you started.</p> <p> Your first component</p><p>Learn the basics of composing a UI component with Pret.</p><p> Sharing state</p><p>Learn how to manage the state of your app and share it between multiple components.</p><p> Tic Tac Toe</p><p>Building what we have learned in the previous tutorials, let's build a Tic Tac Toe game.</p><p> Interacting with the server</p><p>Learn how to run server-side code and interact with the server from the client, and vice-versa.</p>"},{"location":"tutorials/create-your-first-component/","title":"Your first component","text":""},{"location":"tutorials/create-your-first-component/#your-first-component","title":"Your first component","text":"<p>Let's create a first UI component with Pret. We will start simple, with the \"Hello World\" of UI components: a Todo list.</p> <p>Pret is a declarative UI library, which means that you describe the UI you want, and Pret takes care of rendering it for you. Under the hood, we use React and React libraries to render the UI.</p>"},{"location":"tutorials/create-your-first-component/#composing-components","title":"Composing components","text":"<p>Our app should be able to display a list of todos, where each todo is described by a text and a boolean indicating whether it is done or not. Let's use Joy's Checkbox for this:</p> <pre><code>from pret.ui.joy import Checkbox\n\nCheckbox(\n    label=\"My first todo\",\n    checked=True,\n)\n</code></pre> <p>Great ! We successfully declared and rendered our first component. Let's make it a list. We will use the Stack component to stack multiple components vertically. To compose components, we pass checkboxes as positional arguments (or a list) to the Stack component, and Pret will render them as children of the Stack component.</p> <pre><code>from pret.ui.joy import Checkbox, Stack\n\nStack(\n    Checkbox(label=\"My first todo\", checked=True),\n    Checkbox(label=\"My second todo\", checked=False),\n)\n</code></pre> <p>Instead of hardcoding the todos, we can use a list of todos and a loop to render them:</p> <pre><code>from pret.ui.joy import Checkbox, Stack\n\ntodos = [\n    {\"text\": \"My first todo\", \"done\": True},\n    {\"text\": \"My second todo\", \"done\": False},\n]\n\nStack(\n    [\n        Checkbox(label=todo[\"text\"], checked=todo[\"done\"])\n        for todo in todos\n    ],\n    spacing=2,\n)\n</code></pre> <p>We can turn this into a TodoList component, so that we can reuse it later:</p> <pre><code>from pret import component\n\n\n@component\ndef TodoList(todos):\n    return Stack(\n        [\n            Checkbox(label=todo[\"text\"], checked=todo[\"done\"])\n            for todo in todos\n        ],\n        spacing=2,\n    )\n\n\nTodoList(todos=todos)  # (1)!\n</code></pre> <ol> <li>Here, <code>todos</code> are not children components but parameters of the <code>TodoList</code> component, also known as <code>props</code> in React, so we pass them as keyword arguments. In fact, passing them as positional arguments would raise an error.</li> </ol>"},{"location":"tutorials/create-your-first-component/#reacting-to-events","title":"Reacting to events","text":"<p>Now that we have a list of todos, we want to be able to mark them as done or not. We can use the <code>on_change</code> event of the Checkbox component to react to changes. For now, let's just make a popup appear when a todo is checked or unchecked.</p> <pre><code>from pret.ui.joy import Checkbox, Stack\n\n\ndef on_change(event):\n    checked = event.target.checked\n    alert(f\"Todo {'checked' if checked else 'unchecked'}\")\n\n\nCheckbox(\n    label=\"My first todo\",\n    checked=True,\n    on_change=on_change,\n)\n</code></pre>"},{"location":"tutorials/create-your-first-component/#adding-state","title":"Adding state","text":"<p>Our app is still a bit static : you may have noticed that you cannot change the value of the checboxes. We need to add state to our app to keep track of the todos' state. Let's start simple by making a Counter component that increments a counter each time a button is clicked. We can use the <code>use_state</code> hook, which allows us to create a state variable that will persist across renders (calls of our component) and trigger a re-render when its value changes.</p> <pre><code>from pret.ui.joy import Button, Typography, Stack\nfrom pret import component, use_state\n\n\n@component\ndef Counter():\n    count, set_count = use_state(0)\n\n    def increment(event):\n        set_count(count + 1)\n\n    return Stack(\n        [\n            Button(\"Increment\", on_click=increment),\n            Typography(f\"Count: {count}\"),\n        ],\n        spacing=2,\n    )\n\nCounter()\n</code></pre> <p>As you can see, every time you click the button, the state changes which triggers a re-render of the component. This is how we can make our TodoList component interactive. We will use the <code>use_state</code> hook to keep track of the todos' state.</p> <pre><code>from pret.ui.joy import Checkbox, Stack\nfrom pret import use_state, component\n\ntodos = [\n    {\"text\": \"My first todo\", \"done\": True},\n    {\"text\": \"My second todo\", \"done\": False},\n]\n\n@component\ndef TodoList(todos):\n    todos, set_todos = use_state(todos)\n\n    def on_change(event, index):\n        new_todos = list(todos)\n        new_todos[index] = {**todos[index], \"done\": event.target.checked}\n        set_todos(new_todos)\n\n    return Stack(\n        [\n            Checkbox(\n                label=todo[\"text\"],\n                checked=todo[\"done\"],\n                on_change=(lambda index: lambda event: on_change(event, index))(index),\n            )\n            for index, todo in enumerate(todos)\n        ],\n        spacing=2,\n    )\n\nTodoList(todos=todos)\n</code></pre>"},{"location":"tutorials/interacting-with-the-server/","title":"Interacting with the server","text":""},{"location":"tutorials/interacting-with-the-server/#interacting-with-the-server","title":"Interacting with the server","text":"<p>In this tutorial, we'll see the difference between server-side and client-side code in Pret, and how to interact with the server from your app.</p>"},{"location":"tutorials/interacting-with-the-server/#client-side-environment","title":"Client-side environment","text":"<p>When you build a Pret app, you are building a web application that will run in the browser. By default, in Pret, any function used in a rendered component will be transpiled into javascript (including its scoped variables), then sent to the browser for execution. While this is a powerful feature, this means that this function doesn't have access to your server-side environment, such as your database, filesystem or computing resources. Moreover, the transpilation process has some limitations: you won't be able to import modules beside the ones provided by Pret, and you won't be able to use some Python features such as decorators, context managers, multithreading, etc.</p> <p>For instance, let's take a look at the following component:</p> <pre><code>import time\n\nfrom pret import component\nfrom pret.ui.react import br\n\nstatic_time = str(time.time())\n\ndef dynamic_client_time():\n    return str(time.time())\n\n@component\ndef ShowCurrentWorkingDirectory():\n    return [\n        f\"Current time when this App was built: {static_time}\",\n        br(),\n        f\"Current CLIENT time when this App is rendered: {dynamic_client_time()}\",\n    ]\n\nShowCurrentWorkingDirectory()\n</code></pre> <p>The \"dynamic\" displayed time will be the one from the browser's. In fact, these docs are hosted as a static website on GitHub Pages, so there is no server-side environment to access during the rendering process. The \"static\" time will be the one from the server-side environment, computed when the component is built and sent as a constant to the browser.</p>"},{"location":"tutorials/interacting-with-the-server/#running-server-side-code","title":"Running server-side code","text":"<p>To tell Pret to run a function on the server-side, you can decorate a function with <code>@server_only</code>. In this case, any call to this function from a client-side function will actually trigger a call to the server, and the result will be sent back to the client asynchronously.</p> <p>Async functions</p> <p>Any function decorated with <code>@server_only</code> becomes an async function from the client's perspective. This means that you must use <code>await</code> on the result of this function to get the actual return value.</p> <p>At the moment, it is not possible to directly await the result of the server function in the rendering function. Therefore, in the example below, we combine <code>@server_only</code> with <code>use_effect</code> to update the displayed current server working directory once it has been fetched from the server.</p> <pre><code>import time\n\nfrom pret import component, server_only, use_effect, use_state\nfrom pret.ui.react import br\n\n\n@server_only\ndef dynamic_server_time():\n    time.sleep(4)\n    return str(time.time())\n\n\ndef dynamic_client_time():\n    return str(time.time())\n\n\nstatic_time = str(time.time())\n\n\n@component\ndef ShowCurrentWorkingDirectory():\n    server_time, set_server_time = use_state(None)\n\n    async def on_load():\n        set_server_time(await dynamic_server_time())\n\n    use_effect(on_load, [])\n\n    return [\n        f\"Current time when this App was built: {static_time}\",\n        br(),\n        f\"Current CLIENT time when this App is rendered: {dynamic_client_time()}\",\n        br(),\n        f\"Current SERVER time when this App is rendered: {server_time or 'Waiting for server...'}\",\n    ]\n\nShowCurrentWorkingDirectory()\n</code></pre> <p>Since this app is hosted on GitHub Pages, there is no server-side environment to access. However, you can run this code in a notebook to see the difference between the client and server working directories.</p>"},{"location":"tutorials/interacting-with-the-server/#synchronizing-client-and-server-side-stores","title":"Synchronizing client and server-side stores","text":"<p>In the last Sharing state tutorial, we saw how to create a store shared between components with <code>store = create_store(...)</code>. This store lives in the browser's memory, and is not accessible from the server. This means that once you have run your app, the <code>store</code> variable in your notebook will not be updated when the state in the browser is updated.</p> <p>Pret offers a simple way to synchronize this store object between the client and the server, by using the <code>sync</code> option in the <code>create_store</code> function. This option will keep both server and client states in sync whenever one of them is updated. Under the hood, the store is managed as a CRDT (Conflict-free Replicated Data Type) with Yjs and py-crdt, and only the changes are sent to the other side.</p> <pre><code>from pret.ui.joy import Button\nfrom pret import component, create_store\nfrom pret.hooks import use_store_snapshot\n\nstore = create_store({\n    \"count\": 0,\n}, sync=True)\n\n\n@component\ndef Counter():\n    tracked = use_store_snapshot(store)\n\n    def increment(event):\n        store[\"count\"] += 1\n\n    return Button(f\"Count: {tracked['count']}. Click to increment\", on_click=increment)\n\n\nCounter()\n</code></pre> <p>In your notebook, you can now change the <code>store[\"count\"]</code> variable in another cell, and observe the change in the browser. Conversely, you can click the \"Increment\" button in the browser, and print the <code>store[\"count\"]</code> variable in your notebook to see the change.</p> <pre><code># Show the current count, synchronized with the browser\nprint(store[\"count\"])\n\n# Change the count from the notebook\nstore[\"count\"] = 42\n</code></pre>"},{"location":"tutorials/interacting-with-the-server/#persisting-the-store-to-the-file-system","title":"Persisting the store to the file system","text":"<p>Passing a file path to the <code>sync</code> option makes the store persistent across server restarts and enables collaboration even when several kernels run in different processes. Every update is appended to the file as a binary Yjs CRDT update. Each server watches the file for changes so that edits made by another process are picked up and broadcasted to its connected clients.</p> <pre><code>store = create_store({\"count\": 0}, sync=\"./shared_state.bin\")\n</code></pre> <p>If another instance of your application uses the same file path, all changes will be merged and synchronized between all clients and servers.</p>"},{"location":"tutorials/sharing-state/","title":"Sharing state","text":""},{"location":"tutorials/sharing-state/#sharing-state","title":"Sharing state","text":"<p>In the previous tutorial, we have seen how to compose a simple component from other components, how to render it, and detect user events. In this tutorial, we will see how to share state between components.</p>"},{"location":"tutorials/sharing-state/#the-state-management-problem","title":"The state management problem","text":"<p>Why is state management hard in web development? The dynamic nature of user interfaces means multiple components must reflect and react to shared and changing data without re-rendering everything anytime something changes (e.g, you recompute the whole app UI whenever a single state variable changes), or convoluted data flows (e.g., state being passed through many layers of components that don\u2019t even use it). Traditional approaches, like Redux, often introduce layers of boilerplate and require careful architecture when planning mutations on the app data.</p> <p>There is another issue of immutability: we cannot mutate the state directly (e.g., <code>state.todos[0][\"done\"] = True</code>), since React, and thus Pret, often relies on shallow comparison to detect changes in the state. For instance, if <code>todos</code> is the same object, even though its content has changed, some React utils (e.g. memo) will consider that the state has not changed and will not trigger a re-render.</p> <p>And if we take care of preventing direct mutations, changing the state can be cumbersome. For instance, if we want to change the <code>done</code> field of the first todo, we would have to do something like this:</p> <pre><code>new_todos = list(todos)\nnew_todos[0] = {**todos[0], \"done\": True}\n\n# We now have todos != new_todos and\n# todos[i] == new_todos[i] for all i except 0\n</code></pre>"},{"location":"tutorials/sharing-state/#prets-store-system","title":"Pret's store system","text":"<p>Pret provides a simple way to manage state in your components. A store, powered by Yjs and py-crdt, can be created and shared between components. Mutations to the state are made easy, and the app automatically knows which components should be re-rendered when a given part of the state changes.</p> <p>To create a store, we use the <code>create_store</code> wrapper:</p> <pre><code>from pret import create_store\nfrom pret.store import subscribe\n\nstore = create_store(\n    {\n        \"todos\": [\n            {\"text\": \"My first todo\", \"done\": True},\n            {\"text\": \"My second todo\", \"done\": False},\n        ],\n        \"letters\": [\"a\", \"b\"],\n    }\n)\n\n\ndef on_event(ops):\n    for op in ops:\n        print(op.path, \"=&gt;\", op.keys if hasattr(op, \"keys\") else op.delta)\n\n\nsubscribe(store, callback=on_event)\nstore[\"todos\"][1][\"done\"] = True\n# Out: ['todos', 1] =&gt; {'done': {'action': 'update', 'oldValue': False, 'newValue': True}}\n\ndel store[\"todos\"][1][\"done\"]\n# Out: ['todos', 1] =&gt; {'done': {'action': 'delete', 'oldValue': True}}\n\nstore[\"todos\"][1][\"cool\"] = True\n# Out: ['todos', 1] =&gt; {'cool': {'action': 'add', 'newValue': True}}\n\nstore[\"letters\"].append(\"c\")\n# Out: ['letters'] =&gt; [{'retain': 2}, {'insert': ['c']}]\n\nstore[\"letters\"][1] = \"z\"\n# Out: ['letters'] =&gt; [{'retain': 1}, {'delete': 1}, {'insert': ['z']}]\n</code></pre> <p>Supported types</p> <p>At the moment, not all types can be used in a Pret store. We focus on supporting the most common container types, such as lists and dictionaries, in addition to the basic types (int, float, str, bool, None).</p>"},{"location":"tutorials/sharing-state/#using-stores-in-components","title":"Using stores in components","text":"<p>Now that we have a store object, we can use it in our components. To let Pret know that a component should re-render when a part of the state changes, we use the <code>use_store_snapshot</code> hook, which returns a snapshot of the state. This hook tracks access made on the state, and if a mutation on a part of the state that was accessed is detected :</p> <ul> <li>the component will re-render</li> <li>the snapshot will be different from the previous one (meaning, we don't have the <code>new_todos is todos</code> issue mentioned earlier)</li> </ul> <pre><code>from pret import component, use_store_snapshot, create_store\nfrom pret.ui.joy import Checkbox, Stack\n\nstore = create_store({\n    \"todos\": [\n        {\"text\": \"My first todo\", \"done\": True},\n        {\"text\": \"My second todo\", \"done\": False},\n    ],\n})\n\n\n@component\ndef TodoList():  # (1)!\n    todos = use_store_snapshot(store[\"todos\"])\n\n    def on_change(event, i):\n        store[\"todos\"][i][\"done\"] = event.target.checked\n\n    return Stack(\n        [\n            Checkbox(\n                label=todo[\"text\"],\n                checked=todo[\"done\"],\n                on_change=lambda event, i=i: on_change(event, i),\n            )\n            for i, todo in enumerate(todos)\n        ],\n        spacing=2,\n    )\n\n\nTodoList()\n</code></pre> <ol> <li>Note that we don't pass the <code>todos</code> as an argument to the <code>TodoList</code> component anymore. Instead, we use the <code>use_store_snapshot</code> hook to directly subscribe to the global <code>store</code> object.</li> </ol>"},{"location":"tutorials/sharing-state/#sharing-state-between-components","title":"Sharing state between components","text":"<p>Sharing state between components is now straightforward. Let's display the number of remaining todos in the list. We will use the same <code>store</code> object as the component above.</p> <pre><code>from pret.ui.joy import Typography\nfrom pret.ui.react import br\n\n@component\ndef RemainingTodoCounter():\n    todos = use_store_snapshot(store[\"todos\"])\n    num_remaining = sum(not todo[\"done\"] for todo in todos)\n\n    return Typography(\n        f\"Number of unfinished todos: {num_remaining}.\",\n        br(),\n        \"Click todos in the previous component to change the count.\",\n    )\n\nRemainingTodoCounter()\n</code></pre>"},{"location":"tutorials/tictactoe/","title":"TicTacToe","text":""},{"location":"tutorials/tictactoe/#tictactoe","title":"TicTacToe","text":"<p>Let's build a simple TicTacToe game using Pret. We will build a simple game where two players can play against each other.</p> <pre><code>from pret import create_store, component\nfrom pret.ui.react import button, div\nfrom pret.hooks import use_store_snapshot\n\nstate = create_store({\n    \"board\": [0] * 9,\n    \"turn\": 1,\n    \"winning_pattern\": [],\n})\n\nwinning_patterns = [\n    [0, 1, 2],\n    [3, 4, 5],\n    [6, 7, 8],\n    [0, 3, 6],\n    [1, 4, 7],\n    [2, 5, 8],\n    [0, 4, 8],\n    [6, 4, 2],\n]\n\nSQUARE_STYLE = {\n    \"display\": \"flex\",\n    \"justifyContent\": \"center\",\n    \"alignItems\": \"center\",\n    \"width\": \"60px\",\n    \"height\": \"60px\",\n    \"margin\": \"2px\",\n    \"fontSize\": \"24px\",\n    \"padding\": \"0\",\n    \"appearance\": \"none\",\n    \"border\": \"1px solid grey\",\n}\n\nWINNING_SQUARE_STYLE = {\n    **SQUARE_STYLE,\n    \"background\": \"lightGreen\",\n}\n\nGRID_STYLE = {\n    \"display\": \"grid\",\n    \"gridTemplateColumns\": \"repeat(3, 66px)\",\n    \"gridGap\": \"2px\",\n}\n\n\n@component\ndef TicTacToe():\n    tracked = use_store_snapshot(state)\n    winning_pattern = tracked[\"winning_pattern\"]\n\n    def on_click_square(idx):\n        # if the game is over, clean everything on click\n        if bool(state[\"winning_pattern\"]) or 0 not in state[\"board\"]:\n            state[\"board\"][:] = [0 for _ in range(9)]\n            state[\"winning_pattern\"] = []\n            return\n\n        # place a piece on the board\n        value = state[\"board\"][idx]\n        if value == 0:\n            state[\"board\"][idx] = state[\"turn\"]\n        state[\"turn\"] = 2 if state[\"turn\"] == 1 else 1\n\n        # check for victory\n        for pattern in winning_patterns:\n            players = set(state[\"board\"][i] for i in pattern)\n            if len(players) == 1 and 0 not in players:\n                state[\"winning_pattern\"] = pattern\n\n    return div(\n        [\n            button(\n                \"X\" if square == 2 else \"O\" if square == 1 else \"\",\n                on_click=lambda event, idx=idx: on_click_square(idx),\n                style=(\n                    WINNING_SQUARE_STYLE if idx in winning_pattern else SQUARE_STYLE\n                ),\n            )\n            for idx, square in enumerate(tracked[\"board\"])\n        ],\n        style=GRID_STYLE,\n    )\n\n\nTicTacToe()\n</code></pre>"},{"location":"reference/pret/","title":"<code>pret</code>","text":""},{"location":"reference/pret/#pret.run","title":"<code>run</code>","text":"<p>Serve the app, after building the app if necessary.</p>"},{"location":"reference/pret/#pret.run--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>renderable</code> <p>The renderable object to be served</p> <p> </p> <code>static_dir</code> <p>The directory where the static files will be stored</p> <p> TYPE: <code>Optional[Union[str, Path]]</code> DEFAULT: <code>None</code> </p> <code>build_dir</code> <p>The directory where the build files will be stored</p> <p> TYPE: <code>Optional[Union[str, Path]]</code> DEFAULT: <code>None</code> </p> <code>bundle</code> <p>The mode to use for bundling :</p> <ul> <li>\"federated\": The app will be bundled where the assets are   just copied from each package. This means that there may   be repeated assets in the final bundle.</li> <li>\"monolithic\": The app will be bundled where a consolidated   bundle is created with all the assets, using webpack.</li> </ul> <p>By default, the mode is \"federated\".</p> <p> TYPE: <code>Union[bool, str, BundleMode]</code> DEFAULT: <code>True</code> </p> <code>dev</code> <p>Only used when mode is \"monolithic\". If True, the bundle will be created in development mode. Otherwise, it will be created in production mode.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>serve</code> <p>Whether to serve the app after building it.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>port</code> <p>The port to use for serving the app.</p> <p> TYPE: <code>int</code> DEFAULT: <code>5000</code> </p>"},{"location":"reference/pret/#pret.component","title":"<code>component</code>","text":"<p>Decorator to turn a Python function into a Pret component, that will be rendered by React.</p>"},{"location":"reference/pret/#pret.component--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>fn</code> <p> TYPE: <code>Callable</code> </p>"},{"location":"reference/pret/#pret.create_store","title":"<code>create_store</code>","text":"<p>Create a new store that can be used to store and synchronize data between various components of the app, between a server and its clients, or between different processes (or across multiple runs of the app) using a file.</p>"},{"location":"reference/pret/#pret.create_store--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>data</code> <p>Initial data to store in the document. It can be a dictionary, list, or any simple value.</p> <p> </p> <code>sync</code> <p>There are three options for this parameter:</p> <ul> <li>If false, this store will not be synchronized between a server and its   clients. This can be useful for local-only stores, like style management.</li> <li>If true, the store will be synchronized between a server and its clients.   Any changes made to the store will be sent to the server and vice versa.</li> <li>If a path is provided, the store will be synchronized with the file at this   path. Any changes made to the store will be written to the file, and any   changes made to the file will be read into the store. This can be useful   if you want to persist the store to disk or share it between different   processes (think servers or kernels).</li> </ul> <p> TYPE: <code>Optional[Union[bool, str, PathLike]]</code> DEFAULT: <code>None</code> </p>"},{"location":"reference/pret/#pret.use_callback","title":"<code>use_callback</code>","text":"<p>Returns a memoized callback function. The callback will be stable across re-renders, as long as the dependencies don't change, meaning the last callback function passed to this function will be used between two re-renders.</p> <p>Note</p> <p>Ensure that dependencies are simple values like int, str, bool to avoid unnecessary re-executions, as these values are converted to JavaScript objects, and converting complex objects may not ensure referential equality.</p>"},{"location":"reference/pret/#pret.use_callback--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>callback</code> <p>The callback function</p> <p> TYPE: <code>C</code> </p> <code>dependencies</code> <p>The dependencies that will trigger a re-execution of the callback.</p> <p> TYPE: <code>Optional[List]</code> DEFAULT: <code>None</code> </p>"},{"location":"reference/pret/#pret.use_effect","title":"<code>use_effect</code>","text":"<p>The <code>useEffect</code> hook allows you to perform side effects in function components. Side effects can include data fetching, subscriptions, manually changing the DOM, and more.</p> <p>The effect runs after every render by default. If <code>dependencies</code> are provided, the effect runs whenever those values change. Therefore, if <code>dependencies</code> is an empty array, the effect runs only once after the initial render.</p> <p>Note</p> <p>Ensure that dependencies are simple values like int, str, bool to avoid unnecessary re-executions, as these values are converted to javascript objects, and converting complex objects may not ensure referential equality.</p>"},{"location":"reference/pret/#pret.use_effect--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>effect</code> <p>A function containing the side effect logic. It can optionally return a cleanup function.</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>None</code> </p> <code>dependencies</code> <p>An optional array of dependencies that determines when the effect runs.</p> <p> TYPE: <code>Optional[List]</code> DEFAULT: <code>None</code> </p>"},{"location":"reference/pret/#pret.use_memo","title":"<code>use_memo</code>","text":"<p>Returns a memoized value, computed from the provided function. The function will only be re-executed if any of the dependencies change.</p> <p>Note</p> <p>Ensure that dependencies are simple values like int, str, bool to avoid unnecessary re-executions, as these values are converted to javascript objects, and converting complex objects may not ensure referential equality.</p>"},{"location":"reference/pret/#pret.use_memo--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>fn</code> <p>The function to run to compute the memoized value</p> <p> TYPE: <code>Callable[[], T]</code> </p> <code>dependencies</code> <p>The dependencies that will trigger a re-execution of the function</p> <p> TYPE: <code>List</code> </p> RETURNS DESCRIPTION <code>FunctionReturnType</code> <p>The value</p>"},{"location":"reference/pret/#pret.use_ref","title":"<code>use_ref</code>","text":"<p>Returns a mutable ref object whose <code>.current</code> property is initialized to the passed argument.</p> <p>The returned object will persist for the full lifetime of the component.</p>"},{"location":"reference/pret/#pret.use_ref--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>initial_value</code> <p>The initial value of the ref</p> <p> TYPE: <code>RefValueType</code> </p> RETURNS DESCRIPTION <code>RefType[RefValueType]</code> <p>The ref object</p>"},{"location":"reference/pret/#pret.use_state","title":"<code>use_state</code>","text":"<p>Returns a stateful value, and a function to update it.</p>"},{"location":"reference/pret/#pret.use_state--examples","title":"Examples","text":"<pre><code>from pret.ui.react import div, button, p\nfrom pret import component, use_state\n\n\n@component\ndef CounterApp():\n    count, set_count = use_state(0)\n\n    def increment():\n        set_count(count + 1)\n\n    return div(p(count), button({\"onClick\": increment}, \"Increment\"))\n</code></pre>"},{"location":"reference/pret/#pret.use_state--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>initial_value</code> <p>The initial value of the state</p> <p> TYPE: <code>StateValueType</code> </p> RETURNS DESCRIPTION <code>Tuple[StateValueType, Callable[[StateValueType], None]]</code> <ul> <li>The current value of the state</li> <li>A function to update the state</li> </ul>"},{"location":"reference/pret/#pret.use_store_snapshot","title":"<code>use_store_snapshot</code>","text":"<p>This hook is used to track the access made on a store. You cannot use the returned object to change the store, you must mutate the original create_store(...) object directly.</p>"},{"location":"reference/pret/#pret.use_store_snapshot--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>proxy_object</code> <p>A store object, like the one returned by <code>create_store({...})</code></p> <p> </p> RETURNS DESCRIPTION <code>TrackedProxyType</code> <p>A tracked store object</p>"},{"location":"reference/pret/#pret.use_event_callback","title":"<code>use_event_callback</code>","text":"<p>This hook is used to store a callback function that will be called when an event is triggered. The callback function can be changed without triggering a re-render of the component. The function returns a wrapped callback function that will in turn call the stored callback function.</p> <p>Warning</p> <p>Do not use this hook if the rendering of the component depends on the callback function.</p>"},{"location":"reference/pret/#pret.use_event_callback--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>callback</code> <p>The callback function</p> <p> TYPE: <code>C</code> </p> RETURNS DESCRIPTION <code>C</code> <p>The wrapped callback function</p>"},{"location":"reference/pret/cli/","title":"<code>pret.cli</code>","text":""},{"location":"reference/pret/cli/prepack_command/","title":"<code>pret.cli.prepack_command</code>","text":""},{"location":"reference/pret/cli/prepack_command/#pret.cli.prepack_command.prepack","title":"<code>prepack</code>","text":"<p>Pre-packs a stub module into a single javascript file.</p>"},{"location":"reference/pret/cli/prepack_command/#pret.cli.prepack_command.prepack--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>stub_module</code> <p>The name of the stub module to prepack.</p> <p> TYPE: <code>str</code> </p> <code>output_path</code> <p>The path to the output file.</p> <p> TYPE: <code>str</code> </p> <code>cwd</code> <p>Whether to add the current working directory to the python path.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p>"},{"location":"reference/pret/cli/stub_command/","title":"<code>pret.cli.stub_command</code>","text":""},{"location":"reference/pret/cli/update_jupyter_config/","title":"<code>pret.cli.update_jupyter_config</code>","text":""},{"location":"reference/pret/cli/update_jupyter_config/#pret.cli.update_jupyter_config.find_home_config_dir","title":"<code>find_home_config_dir</code>","text":"<p>Choose a config directory that lives in the user's HOME (e.g. ~/.jupyter), not inside the active conda environment.</p>"},{"location":"reference/pret/cli/update_jupyter_config/#pret.cli.update_jupyter_config.env_labextensions_dir","title":"<code>env_labextensions_dir</code>","text":"<p>Compute /share/jupyter/labextensions for the active environment."},{"location":"reference/pret/cli/update_jupyter_config/#pret.cli.update_jupyter_config.set_extra_labextensions_path","title":"<code>set_extra_labextensions_path</code>","text":"<p>Create or update jupyter_server_config.py to set:   c.LabServerApp.extra_labextensions_path = [\"\", ...] If a previous assignment exists, replace it, otherwise append. Returns a tuple of (old_line, new_line, backup_path) where backup_path is the path to the backup file if created."},{"location":"reference/pret/hooks/","title":"<code>pret.hooks</code>","text":""},{"location":"reference/pret/hooks/#pret.hooks.use_state","title":"<code>use_state</code>","text":"<p>Returns a stateful value, and a function to update it.</p>"},{"location":"reference/pret/hooks/#pret.hooks.use_state--examples","title":"Examples","text":"<pre><code>from pret.ui.react import div, button, p\nfrom pret import component, use_state\n\n\n@component\ndef CounterApp():\n    count, set_count = use_state(0)\n\n    def increment():\n        set_count(count + 1)\n\n    return div(p(count), button({\"onClick\": increment}, \"Increment\"))\n</code></pre>"},{"location":"reference/pret/hooks/#pret.hooks.use_state--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>initial_value</code> <p>The initial value of the state</p> <p> TYPE: <code>StateValueType</code> </p> RETURNS DESCRIPTION <code>Tuple[StateValueType, Callable[[StateValueType], None]]</code> <ul> <li>The current value of the state</li> <li>A function to update the state</li> </ul>"},{"location":"reference/pret/hooks/#pret.hooks.use_memo","title":"<code>use_memo</code>","text":"<p>Returns a memoized value, computed from the provided function. The function will only be re-executed if any of the dependencies change.</p> <p>Note</p> <p>Ensure that dependencies are simple values like int, str, bool to avoid unnecessary re-executions, as these values are converted to javascript objects, and converting complex objects may not ensure referential equality.</p>"},{"location":"reference/pret/hooks/#pret.hooks.use_memo--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>fn</code> <p>The function to run to compute the memoized value</p> <p> TYPE: <code>Callable[[], T]</code> </p> <code>dependencies</code> <p>The dependencies that will trigger a re-execution of the function</p> <p> TYPE: <code>List</code> </p> RETURNS DESCRIPTION <code>FunctionReturnType</code> <p>The value</p>"},{"location":"reference/pret/hooks/#pret.hooks.use_ref","title":"<code>use_ref</code>","text":"<p>Returns a mutable ref object whose <code>.current</code> property is initialized to the passed argument.</p> <p>The returned object will persist for the full lifetime of the component.</p>"},{"location":"reference/pret/hooks/#pret.hooks.use_ref--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>initial_value</code> <p>The initial value of the ref</p> <p> TYPE: <code>RefValueType</code> </p> RETURNS DESCRIPTION <code>RefType[RefValueType]</code> <p>The ref object</p>"},{"location":"reference/pret/hooks/#pret.hooks.use_callback","title":"<code>use_callback</code>","text":"<p>Returns a memoized callback function. The callback will be stable across re-renders, as long as the dependencies don't change, meaning the last callback function passed to this function will be used between two re-renders.</p> <p>Note</p> <p>Ensure that dependencies are simple values like int, str, bool to avoid unnecessary re-executions, as these values are converted to JavaScript objects, and converting complex objects may not ensure referential equality.</p>"},{"location":"reference/pret/hooks/#pret.hooks.use_callback--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>callback</code> <p>The callback function</p> <p> TYPE: <code>C</code> </p> <code>dependencies</code> <p>The dependencies that will trigger a re-execution of the callback.</p> <p> TYPE: <code>Optional[List]</code> DEFAULT: <code>None</code> </p>"},{"location":"reference/pret/hooks/#pret.hooks.use_effect","title":"<code>use_effect</code>","text":"<p>The <code>useEffect</code> hook allows you to perform side effects in function components. Side effects can include data fetching, subscriptions, manually changing the DOM, and more.</p> <p>The effect runs after every render by default. If <code>dependencies</code> are provided, the effect runs whenever those values change. Therefore, if <code>dependencies</code> is an empty array, the effect runs only once after the initial render.</p> <p>Note</p> <p>Ensure that dependencies are simple values like int, str, bool to avoid unnecessary re-executions, as these values are converted to javascript objects, and converting complex objects may not ensure referential equality.</p>"},{"location":"reference/pret/hooks/#pret.hooks.use_effect--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>effect</code> <p>A function containing the side effect logic. It can optionally return a cleanup function.</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>None</code> </p> <code>dependencies</code> <p>An optional array of dependencies that determines when the effect runs.</p> <p> TYPE: <code>Optional[List]</code> DEFAULT: <code>None</code> </p>"},{"location":"reference/pret/hooks/#pret.hooks.use_store_snapshot","title":"<code>use_store_snapshot</code>","text":"<p>This hook is used to track the access made on a store. You cannot use the returned object to change the store, you must mutate the original create_store(...) object directly.</p>"},{"location":"reference/pret/hooks/#pret.hooks.use_store_snapshot--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>proxy_object</code> <p>A store object, like the one returned by <code>create_store({...})</code></p> <p> </p> RETURNS DESCRIPTION <code>TrackedProxyType</code> <p>A tracked store object</p>"},{"location":"reference/pret/hooks/#pret.hooks.use_event_callback","title":"<code>use_event_callback</code>","text":"<p>This hook is used to store a callback function that will be called when an event is triggered. The callback function can be changed without triggering a re-render of the component. The function returns a wrapped callback function that will in turn call the stored callback function.</p> <p>Warning</p> <p>Do not use this hook if the rendering of the component depends on the callback function.</p>"},{"location":"reference/pret/hooks/#pret.hooks.use_event_callback--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>callback</code> <p>The callback function</p> <p> TYPE: <code>C</code> </p> RETURNS DESCRIPTION <code>C</code> <p>The wrapped callback function</p>"},{"location":"reference/pret/ipython_var_cleaner/","title":"<code>pret.ipython_var_cleaner</code>","text":""},{"location":"reference/pret/main/","title":"<code>pret.main</code>","text":""},{"location":"reference/pret/main/#pret.main.build","title":"<code>build</code>","text":"<p>Build the Pret app, pooling all the assets and entry points from the packages that were accessed for rendering.</p>"},{"location":"reference/pret/main/#pret.main.build--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>renderables</code> <p>The list of renderables to be bundled</p> <p> </p> <code>static_dir</code> <p>The directory where the static files will be stored</p> <p> TYPE: <code>Union[str, Path]</code> DEFAULT: <code>None</code> </p> <code>build_dir</code> <p>The directory where the build files will be stored</p> <p> TYPE: <code>Union[str, Path]</code> DEFAULT: <code>None</code> </p> <code>mode</code> <p>The mode to use for bundling :</p> <ul> <li>\"federated\": The app will be bundled where the assets are   just copied from each package. This means that there may   be repeated assets in the final bundle.</li> <li>\"monolithic\": The app will be bundled where a consolidated   bundle is created with all the assets, using webpack.</li> </ul> <p>By default, the mode is \"federated\".</p> <p> TYPE: <code>Union[bool, str, BundleMode]</code> DEFAULT: <code>True</code> </p> <code>dev</code> <p>Only used when mode is \"monolithic\". If True, the bundle will be created in development mode. Otherwise, it will be created in production mode.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Tuple[Dict[str, Union[str, Path]], List[Tuple[str, str]], str]</code> <p>A tuple containing the assets, entries and pickle filename</p>"},{"location":"reference/pret/main/#pret.main.extract_js_dependencies","title":"<code>extract_js_dependencies</code>","text":"<p>Create a js file that will import all the globals that were accessed during pickling and assign them to the global scope.</p>"},{"location":"reference/pret/main/#pret.main.extract_js_dependencies--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>refs</code> <p>List of Ref objects that were accessed during pickling</p> <p> </p> <code>exclude</code> <p>List of module patterns to exclude from the js globals file</p> <p> DEFAULT: <code>('js.React.*', 'js.ReactDOM.*')</code> </p>"},{"location":"reference/pret/main/#pret.main.extract_prebuilt_extension_assets","title":"<code>extract_prebuilt_extension_assets</code>","text":"<p>Extracts entry javascript files from the static directory of each package as well as a mapping entry -&gt; file to know where to look for whenever the app asks for a chunk or an asset.</p>"},{"location":"reference/pret/main/#pret.main.extract_prebuilt_extension_assets--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>packages</code> <p> TYPE: <code>List[str]</code> </p> RETURNS DESCRIPTION <code>Tuple[Dict[str, Path], List[Tuple[str, str]]]</code>"},{"location":"reference/pret/main/#pret.main.extract_prebuilt_base_assets","title":"<code>extract_prebuilt_base_assets</code>","text":"<p>Extracts the base index.html file as well as a mapping entry -&gt; file to know where to look for whenever the app asks for a chunk or an asset.</p>"},{"location":"reference/pret/main/#pret.main.extract_prebuilt_base_assets--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>Returns</code> <code>Tuple</code>"},{"location":"reference/pret/main/#pret.main.run","title":"<code>run</code>","text":"<p>Serve the app, after building the app if necessary.</p>"},{"location":"reference/pret/main/#pret.main.run--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>renderable</code> <p>The renderable object to be served</p> <p> </p> <code>static_dir</code> <p>The directory where the static files will be stored</p> <p> TYPE: <code>Optional[Union[str, Path]]</code> DEFAULT: <code>None</code> </p> <code>build_dir</code> <p>The directory where the build files will be stored</p> <p> TYPE: <code>Optional[Union[str, Path]]</code> DEFAULT: <code>None</code> </p> <code>bundle</code> <p>The mode to use for bundling :</p> <ul> <li>\"federated\": The app will be bundled where the assets are   just copied from each package. This means that there may   be repeated assets in the final bundle.</li> <li>\"monolithic\": The app will be bundled where a consolidated   bundle is created with all the assets, using webpack.</li> </ul> <p>By default, the mode is \"federated\".</p> <p> TYPE: <code>Union[bool, str, BundleMode]</code> DEFAULT: <code>True</code> </p> <code>dev</code> <p>Only used when mode is \"monolithic\". If True, the bundle will be created in development mode. Otherwise, it will be created in production mode.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>serve</code> <p>Whether to serve the app after building it.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>port</code> <p>The port to use for serving the app.</p> <p> TYPE: <code>int</code> DEFAULT: <code>5000</code> </p>"},{"location":"reference/pret/manager/","title":"<code>pret.manager</code>","text":"<p>This module provides client and server managers for handling remote calls, state synchronization, and communication between the frontend and backend.</p>"},{"location":"reference/pret/manager/#pret.manager.JupyterServerManager","title":"<code>JupyterServerManager</code>","text":"<p>           Bases: <code>Manager</code></p>"},{"location":"reference/pret/manager/#pret.manager.JupyterServerManager.close","title":"<code>close</code>","text":"<p>Close method. Closes the underlying comm. When the comm is closed, all the view views are automatically removed from the front-end.</p>"},{"location":"reference/pret/manager/#pret.manager.JupyterServerManager.handle_comm_msg","title":"<code>handle_comm_msg</code>","text":"<p>Called when a message is received from the front-end</p>"},{"location":"reference/pret/manager/#pret.manager.StandaloneClientManager","title":"<code>StandaloneClientManager</code>","text":"<p>           Bases: <code>Manager</code></p>"},{"location":"reference/pret/manager/#pret.manager.is_awaitable","title":"<code>is_awaitable</code>","text":"<p>If the value is an awaitable, await it, otherwise return the value.</p>"},{"location":"reference/pret/manager/#pret.manager.start_async_task","title":"<code>start_async_task</code>","text":"<p>Start an async task and return it.</p>"},{"location":"reference/pret/manager/#pret.manager.b64_encode","title":"<code>b64_encode</code>","text":"<p>Encode bytes to a base64 string.</p>"},{"location":"reference/pret/manager/#pret.manager.b64_decode","title":"<code>b64_decode</code>","text":"<p>Decode a base64 string to bytes.</p>"},{"location":"reference/pret/marshal/","title":"<code>pret.marshal</code>","text":"<p>This module provides marshaling to convert Python objects (and functions, and classes) into a format that can be serialized and later reconstructed in a JavaScript environment.</p>"},{"location":"reference/pret/render/","title":"<code>pret.render</code>","text":"<p>This module provides helpers to create React components from Python functions, and to create components from existing React components. Any component is made renderable in Jupyter by wrapping it in a <code>Renderable</code> object when called from Python.</p>"},{"location":"reference/pret/render/#pret.render.make_create_element_from_function","title":"<code>make_create_element_from_function</code>","text":"<p>Turn a Python Pret function into function that creates a React element.</p>"},{"location":"reference/pret/render/#pret.render.make_create_element_from_function--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>fn</code> <p>The Python function to turn into a React element creator, ie a function that when invoked by React, will call the Python function with the correct arguments.</p> <p> </p> RETURNS DESCRIPTION <code>(**props) -&gt; ReactElement&lt;fn</code>"},{"location":"reference/pret/render/#pret.render.component","title":"<code>component</code>","text":"<p>Decorator to turn a Python function into a Pret component, that will be rendered by React.</p>"},{"location":"reference/pret/render/#pret.render.component--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>fn</code> <p> TYPE: <code>Callable</code> </p>"},{"location":"reference/pret/serve/","title":"<code>pret.serve</code>","text":""},{"location":"reference/pret/store/","title":"<code>pret.store</code>","text":""},{"location":"reference/pret/store/#pret.store.AutoArray","title":"<code>AutoArray</code>","text":"<p>           Bases: <code>Array</code></p> <p>Array subclass to automatically convert assigned values to container types.</p>"},{"location":"reference/pret/store/#pret.store.AutoMap","title":"<code>AutoMap</code>","text":"<p>           Bases: <code>Map</code></p> <p>Map subclass to automatically convert assigned values to container types.</p>"},{"location":"reference/pret/store/#pret.store.AutoDoc","title":"<code>AutoDoc</code>","text":"<p>           Bases: <code>Doc</code></p> <p>Doc with root container values auto converted to AutoArray and AutoMap.</p>"},{"location":"reference/pret/store/#pret.store.AutoDoc.on_update","title":"<code>on_update</code>","text":"<p>Register a callback to be called on document updates.</p>"},{"location":"reference/pret/store/#pret.store.AutoDoc.to_py","title":"<code>to_py</code>","text":"<p>Convert the document to a Python dictionary.</p>"},{"location":"reference/pret/store/#pret.store.create_store","title":"<code>create_store</code>","text":"<p>Create a new store that can be used to store and synchronize data between various components of the app, between a server and its clients, or between different processes (or across multiple runs of the app) using a file.</p>"},{"location":"reference/pret/store/#pret.store.create_store--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>data</code> <p>Initial data to store in the document. It can be a dictionary, list, or any simple value.</p> <p> </p> <code>sync</code> <p>There are three options for this parameter:</p> <ul> <li>If false, this store will not be synchronized between a server and its   clients. This can be useful for local-only stores, like style management.</li> <li>If true, the store will be synchronized between a server and its clients.   Any changes made to the store will be sent to the server and vice versa.</li> <li>If a path is provided, the store will be synchronized with the file at this   path. Any changes made to the store will be written to the file, and any   changes made to the file will be read into the store. This can be useful   if you want to persist the store to disk or share it between different   processes (think servers or kernels).</li> </ul> <p> TYPE: <code>Optional[Union[bool, str, PathLike]]</code> DEFAULT: <code>None</code> </p>"},{"location":"reference/pret/store/#pret.store.subscribe","title":"<code>subscribe</code>","text":"<p>Subscribe to changes in a store.</p>"},{"location":"reference/pret/store/#pret.store.subscribe--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>store</code> <p>The store to subscribe to.</p> <p> TYPE: <code>Any</code> </p> <code>callback</code> <p>The function to call when the object changes.</p> <p> TYPE: <code>callable</code> DEFAULT: <code>None</code> </p> <code>notify_in_sync</code> <p>If True, the callback will be called in sync with the change. Only relevant in the browser environment.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>callable</code> <p>A function that can be used to unsubscribe from the changes.</p>"},{"location":"reference/pret/ui/react/","title":"<code>pret.ui.react</code>","text":""},{"location":"changelog/","title":"v0.4.1 (2025-08-21)","text":"<ul> <li>Added script to update jupyter config to let it know where to find the custom environment data files (including our js artifacts)</li> </ul>"},{"location":"changelog/#v040-2025-08-19","title":"v0.4.0 (2025-08-19)","text":"<ul> <li>Drop valtio in favor of a YJS based shared state management, with a speedup up to 5x for mutations in large arrays.</li> <li>Fixed prepack command that didn't collect used js modules</li> </ul>"},{"location":"changelog/#v030-2025-07-01","title":"v0.3.0 (2025-07-01)","text":"<ul> <li>Add file system persistence for stores, using concatenations of yjs/pycrdt update binaries. Using file watchers, this also enables collaboration between multiple users using different servers/kernels.</li> <li>Renamed <code>proxy(..., remote_sync=...)</code> to <code>create_store(..., sync=...)</code> to better reflect the purpose of the function.</li> <li>Fixed front end to support large binary updates</li> </ul>"},{"location":"changelog/#v020-2025-06-10","title":"v0.2.0 (2025-06-10)","text":"<ul> <li> <p>Major change: I dropped pyodide and replaced it with Python \u2192 JavaScript transpilation (using Transcrypt) on the server. This comes with a few caveats such as the lack of support for some Python constructs and modules (to be documented), but brings a lot of benefits:</p> <ul> <li>Runtime performance: the runtime is now much faster, as it runs in JavaScript the browser and does not require a converting Python objects to JavaScript objects and back.</li> <li>First-time load: the first-time load is now much faster, as we don't require to load the Pyodide runtime and the Python standard library in the browser.</li> <li>Portability: pret can now run without Internet access, as it does not require to load the Pyodide.</li> <li>Error handling: errors (and any thrown object) are now bubbled outside Python and can be handled in JavaScript, which allows for better error handling, as well as throwing Promises to support React Suspense.</li> </ul> </li> <li> <p>Pret tracked proxies are now marshaled as valtio and proxies in the browser: it is no longer possible to mutate the state using the output of <code>use_store_snapshot</code>.</p> </li> <li>Dropped old custom valtio-like python state management, and use (pret-)pycrdt instead</li> <li>Added dependency to pret-pycrdt, fork of pycrdt to support identity preservation and therefore pickling, required for our marshaling mechanism</li> <li>Improved notebook-kernel pret manager synchronization and resynchronization</li> </ul>"},{"location":"changelog/#v010-2025-03-20-initial-release","title":"v0.1.0 (2025-03-20): Initial release","text":"<p>Pret is a library for building full-stack reactive user interfaces in Python, using React as a rendering engine.</p>"},{"location":"changelog/#installation","title":"Installation","text":"<pre><code>pip install pret pret-joy\n</code></pre>"},{"location":"changelog/#features","title":"Features","text":"<ul> <li>Python, only Python: pret is written in Python: you can write your both your UI and server actions Python. No need to learn a new language, or to use a transpiler.</li> <li>Client-side rendering: unlike other Python UI frameworks, pret runs primarily in the browser. This enables a fast response time to user actions (like hover events), and a better user experience under degraded network conditions.</li> <li>Built on React: pret uses React as a rendering engine, and benefits from its ecosystem.</li> <li>Reactive: unlike other solutions like ipywidgets, pret is reactive. Only the parts of the UI that need to be updated are re-rendered.</li> <li>State management: in addition to React's local state management (i.e. <code>use_state</code>), pret provides a global and modular state management solution that is synchronized both between components, and between the client and the server.</li> <li>Modular: pret is designed to be modular. You can easily create your own components, and reuse them in other pret-based projects.</li> <li>Integrated with Jupyter: pret components can be used in Jupyter notebooks, as well as in standalone web applications.</li> <li>Remote execution: pret can call and use the result of Python functions on the server from the browser</li> </ul>"}]}