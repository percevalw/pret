{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":""},{"location":"#getting-started-with-pret","title":"Getting started with Pret","text":"<p>Pret is a library for building full-stack reactive user interfaces in Python, using React as a rendering engine.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pret pret-joy\n</code></pre> <p>To use it with Jupyter, if you install the library in a custom environment (conda, venv, or other), you will likely need to tell Jupyter where to find the front-end files. You can do this by running the following command (only once):</p> <pre><code>pret update-jupyter-config --apply\n</code></pre>"},{"location":"#features","title":"Features","text":"<ul> <li>Python, only Python: pret is written in Python: you can write your both your UI and server actions Python. No need to learn a new language.</li> <li>Client-side rendering: unlike other Python UI frameworks, pret runs primarily in the browser. This enables a fast response time to user actions (like hover events), and a better user experience under degraded network conditions.</li> <li>Built on React: pret uses React as a rendering engine, and benefits from its ecosystem.</li> <li>Reactive: unlike other solutions like ipywidgets, pret is reactive. Only the parts of the UI that need to be updated are re-rendered.</li> <li>State management: in addition to React's local state management (i.e. <code>use_state</code>), pret provides a global and modular state management solution that is synchronized both between components, and between the client and the server.</li> <li>Modular: pret is designed to be modular. You can easily create your own components, and reuse them in other pret-based projects.</li> <li>Integrated with Jupyter: pret components can be used in Jupyter notebooks, as well as in standalone web applications.</li> <li>Remote execution: pret can call and use the result of Python functions on the server from the browser</li> </ul>"},{"location":"#use-it-in-a-notebook","title":"Use it in a notebook","text":"<p>Let's write a simple todo app that should:</p> <ul> <li>display a list of todos, that can be checked as done</li> <li>display the number remaining todos</li> <li>change the font to bold as a todo is hovered</li> <li>allow editing the todo list directly in Python</li> </ul> <p>Copy and paste the following code in a notebook:</p> <pre><code>from pret import component, create_store, run, use_state, use_store_snapshot\nfrom pret_joy import Checkbox, Input, Stack, Typography\n\nstate = create_store(\n  {\n    \"faire \u00e0 manger\": True,\n    \"faire la vaisselle\": False,\n  },\n  sync=True,\n)\n\n\n@component\ndef TodoApp():\n  todos = use_store_snapshot(state)\n  typed, set_typed = use_state(\"\")\n  num_remaining = sum(not ok for ok in todos.values())\n  plural = \"s\" if num_remaining &gt; 1 else \"\"\n\n  def on_key_down(event):\n    if event.key == \"Enter\":\n      state[typed] = False\n      set_typed(\"\")\n\n  return Stack(\n    *(\n      Checkbox(\n        label=todo,\n        checked=ok,\n        on_change=lambda e, t=todo: state.update({t: e.target.checked}),\n      )\n      for todo, ok in todos.items()\n    ),\n    Input(\n      value=typed,\n      on_change=lambda event: set_typed(event.target.value),\n      on_key_down=on_key_down,\n      placeholder=\"Add a todo\",\n    ),\n    Typography(\n      f\"Number of unfinished todo{plural}: {num_remaining}\",\n      sx={\"minWidth\": \"230px\"},  # just to avoid jittering when it's centered\n    ),\n    spacing=2,\n    sx={\"m\": 1},\n  )\n\n\nTodoApp()\n</code></pre> <p>In comparison, the closest alternative using ipywidgets looks like the following snippet:</p> IPyWidget's implementation <pre><code>import ipywidgets as widgets\n\nstate = {\n    \"faire \u00e0 manger\": True,\n    \"faire la vaisselle\": False,\n}\n\n\nclass IPWTodoApp:\n    def __init__(self):\n        self.box = widgets.VBox()\n        self.render()\n\n    def _repr_mimebundle_(self, *args, **kwargs):\n        return self.box._repr_mimebundle_(*args, **kwargs)\n\n    def render(self, *args, **kwargs):\n        num_remaining = sum([not checked for _, checked in state.items()])\n        plural = \"s\" if num_remaining &gt; 1 else \"\"\n\n        def on_input_submit(sender):\n            state[input_widget.value] = False\n            self.render()\n\n        def create_todo_item(todo, checked):\n            def update_todo_status(*args, **kwargs):\n                state[todo] = checkbox.value\n                self.render()\n\n            checkbox = widgets.Checkbox(\n                value=checked,\n                description=todo,\n                disabled=False,\n                indent=False,\n            )\n            checkbox.observe(update_todo_status, names=\"value\")\n            return checkbox\n\n        input_widget = widgets.Text(\n            placeholder=\"Add a todo\",\n            description=\"\",\n            disabled=False,\n        )\n        input_widget.on_submit(on_input_submit)\n\n        self.box.children = [\n            *(create_todo_item(todo, checked) for todo, checked in state.items()),\n            input_widget,\n            widgets.Label(value=f\"Number of unfinished todo{plural}: {num_remaining}\"),\n        ]\n\n\nIPWTodoApp()\n</code></pre> <p>You also lose some features:</p> <ul> <li>the app stops working if the server shuts down</li> <li>hover events cannot be listened to</li> <li>no React dom diffing: the app must either be re-rendered entirely (as in the example),   or you must determine specifically which field of which widget to update</li> </ul>"},{"location":"#use-it-in-a-standalone-app","title":"Use it in a standalone app","text":"<p>You can also use pret to build standalone web applications. Copy the above code in a file named <code>app.py</code>, and change the last line to</p> <pre><code>if __name__ == \"__main__\":\n    run(TodoApp)\n</code></pre> <p>Then, run the following command, and voil\u00e0 !</p> <pre><code>python app.py\n</code></pre>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Here are step-by-step guides to get you started.</p> <p> Your first component</p><p>Learn the basics of composing a UI component with Pret.</p><p> Sharing state</p><p>Learn how to manage the state of your app and share it between multiple components.</p><p> Tic Tac Toe</p><p>Building what we have learned in the previous tutorials, let's build a Tic Tac Toe game.</p><p> Interacting with the server</p><p>Learn how to run server-side code and interact with the server from the client, and vice-versa.</p><p> Widgets</p><p>Learn about Pret widgets: self-contained interactive and controllable components.</p>"},{"location":"tutorials/create-your-first-component/","title":"Your first component","text":""},{"location":"tutorials/create-your-first-component/#your-first-component","title":"Your first component","text":"<p>Let's create a first UI component with Pret. We will start simple, with the \"Hello World\" of UI components: a Todo list.</p> <p>Pret is a declarative UI library, which means that you describe the UI you want, and Pret takes care of rendering it for you. Under the hood, we use React and React libraries to render the UI.</p>"},{"location":"tutorials/create-your-first-component/#composing-components","title":"Composing components","text":"<p>Our app should be able to display a list of todos, where each todo is described by a text and a boolean indicating whether it is done or not. Let's use Joy's Checkbox for this:</p> <pre><code>from pret_joy import Checkbox\n\nCheckbox(\n    label=\"My first todo\",\n    checked=True,\n    sx={\"m\": 1},\n)\n</code></pre> <p>Great ! We successfully declared and rendered our first component. Let's make it a list. We will use the Stack component to stack multiple components vertically. To compose components, we pass checkboxes as positional arguments (or a list) to the Stack component, and Pret will render them as children of the Stack component.</p> <pre><code>from pret_joy import Checkbox, Stack\n\nStack(\n    Checkbox(label=\"My first todo\", checked=True),\n    Checkbox(label=\"My second todo\", checked=False),\n    sx={\"m\": 1},\n)\n</code></pre> <p>Instead of hardcoding the todos, we can use a list of todos and a loop to render them:</p> <pre><code>from pret_joy import Checkbox, Stack\n\ntodos = [\n    {\"text\": \"My first todo\", \"done\": True},\n    {\"text\": \"My second todo\", \"done\": False},\n]\n\nStack(\n    [\n        Checkbox(label=todo[\"text\"], checked=todo[\"done\"])\n        for todo in todos\n    ],\n    spacing=2,\n    sx={\"m\": 1},\n)\n</code></pre> <p>We can turn this into a TodoList component, so that we can reuse it later:</p> <pre><code>from pret import component\nfrom pret_joy import Checkbox, Stack\n\n@component\ndef TodoList(todos):\n    return Stack(\n        [\n            Checkbox(label=todo[\"text\"], checked=todo[\"done\"])\n            for todo in todos\n        ],\n        spacing=2,\n        sx={\"m\": 1},\n    )\n\n\nTodoList(todos=todos)  # (1)!\n</code></pre> <ol> <li>Here, <code>todos</code> are not children components but parameters of the <code>TodoList</code> component, also known as <code>props</code> in React, so we pass them as keyword arguments. In fact, passing them as positional arguments would raise an error.</li> </ol>"},{"location":"tutorials/create-your-first-component/#reacting-to-events","title":"Reacting to events","text":"<p>Now that we have a list of todos, we want to be able to mark them as done or not. We can use the <code>on_change</code> event of the Checkbox component to react to changes. For now, let's just make a popup appear when a todo is checked or unchecked.</p> <pre><code>from pret_joy import Checkbox, Stack\n\ndef on_change(event):\n    checked = event.target.checked\n    alert(f\"Todo {'checked' if checked else 'unchecked'}\")\n\n\nCheckbox(\n    label=\"My first todo\",\n    checked=True,\n    on_change=on_change,\n    sx={\"m\": 1},\n)\n</code></pre>"},{"location":"tutorials/create-your-first-component/#adding-state","title":"Adding state","text":"<p>Our app is still a bit static : you may have noticed that you cannot change the value of the checboxes. We need to add state to our app to keep track of the todos' state. Let's start simple by making a Counter component that increments a counter each time a button is clicked. We can use the <code>use_state</code> hook, which allows us to create a state variable that will persist across renders (calls of our component) and trigger a re-render when its value changes.</p> <pre><code>from pret import component, use_state\nfrom pret_joy import Button, Typography, Stack\n\n@component\ndef Counter():\n    count, set_count = use_state(0)\n\n    def increment(event):\n        set_count(count + 1)\n\n    return Stack(\n        [\n            Button(\"Increment\", on_click=increment),\n            Typography(f\"Count: {count}\"),\n        ],\n        spacing=2,\n        sx={\"m\": 1},\n    )\n\nCounter()\n</code></pre> <p>As you can see, every time you click the button, the state changes which triggers a re-render of the component. This is how we can make our TodoList component interactive. We will use the <code>use_state</code> hook to keep track of the todos' state.</p> <pre><code>from pret import use_state, component\nfrom pret_joy import Checkbox, Stack\n\ntodos = [\n    {\"text\": \"My first todo\", \"done\": True},\n    {\"text\": \"My second todo\", \"done\": False},\n]\n\n@component\ndef TodoList(todos):\n    todos, set_todos = use_state(todos)\n\n    def on_change(event, index):\n        new_todos = list(todos)\n        new_todos[index] = {**todos[index], \"done\": event.target.checked}\n        set_todos(new_todos)\n\n    return Stack(\n        [\n            Checkbox(\n                label=todo[\"text\"],\n                checked=todo[\"done\"],\n                on_change=(lambda index: lambda event: on_change(event, index))(index),\n            )\n            for index, todo in enumerate(todos)\n        ],\n        spacing=2,\n        sx={\"m\": 1},\n    )\n\nTodoList(todos=todos)\n</code></pre>"},{"location":"tutorials/interacting-with-the-server/","title":"Interacting with the server","text":""},{"location":"tutorials/interacting-with-the-server/#interacting-with-the-server","title":"Interacting with the server","text":"<p>In this tutorial, we'll see the difference between server-side and client-side code in Pret, and how to interact with the server from your app.</p>"},{"location":"tutorials/interacting-with-the-server/#client-side-environment","title":"Client-side environment","text":"<p>When you build a Pret app, you are building a web application that will run in the browser. By default, in Pret, any function used in a rendered component will be transpiled into javascript (including its scoped variables), then sent to the browser for execution. While this is a powerful feature, this means that this function doesn't have access to your server-side environment, such as your database, filesystem or computing resources. Moreover, the transpilation process has some limitations: you won't be able to import modules beside the ones provided by Pret, and you won't be able to use some Python features such as decorators, context managers, multithreading, etc.</p> <p>For instance, let's take a look at the following component:</p> <pre><code>import time\n\nfrom pret import component\nfrom pret.react import br, div\n\nstatic_time = str(time.time())\n\n\ndef dynamic_client_time():\n    return str(time.time())\n\n\n@component\ndef ShowCurrentWorkingDirectory():\n    return div(\n        f\"Current time when this App was built: {static_time}\",\n        br(),\n        f\"Current CLIENT time when this App is rendered: {dynamic_client_time()}\",\n        style={\"margin\": \"1em 0\"}\n    )\n\n\nShowCurrentWorkingDirectory()\n</code></pre> <p>The \"dynamic\" displayed time will be the one from the browser's. In fact, these docs are hosted as a static website on GitHub Pages, so there is no server-side environment to access during the rendering process. The \"static\" time will be the one from the server-side environment, computed when the component is built and sent as a constant to the browser.</p>"},{"location":"tutorials/interacting-with-the-server/#running-server-side-code","title":"Running server-side code","text":"<p>To tell Pret to run a function on the server-side, you can decorate a function with <code>@server_only</code>. In this case, any call to this function from a client-side function will actually trigger a call to the server, and the result will be sent back to the client asynchronously.</p> <p>Async functions</p> <p>Any function decorated with <code>@server_only</code> becomes an async function from the client's perspective. This means that you must use <code>await</code> on the result of this function to get the actual return value.</p> <p>At the moment, it is not possible to directly await the result of the server function in the rendering function. Therefore, in the example below, we combine <code>@server_only</code> with <code>use_effect</code> to update the displayed current server working directory once it has been fetched from the server.</p> <pre><code>import time\n\nfrom pret import component, server_only, use_effect, use_state\nfrom pret.react import br, div\n\n\n@server_only\ndef dynamic_server_time():\n    time.sleep(4)\n    return str(time.time())\n\n\ndef dynamic_client_time():\n    return str(time.time())\n\n\nstatic_time = str(time.time())\n\n\n@component\ndef ShowCurrentWorkingDirectory():\n    server_time, set_server_time = use_state(None)\n\n    async def on_load():\n        set_server_time(await dynamic_server_time())\n\n    use_effect(on_load, [])\n\n    return div(\n        f\"Current time when this App was built: {static_time}\",\n        br(),\n        f\"Current CLIENT time when this App is rendered: {dynamic_client_time()}\",\n        br(),\n        f\"Current SERVER time when this App is rendered: {server_time or 'Waiting for server...'}\",\n        style={\"margin\": \"1em 0\"}\n    )\n\n\nShowCurrentWorkingDirectory()\n</code></pre> <p>Since this app is hosted on GitHub Pages, there is no server-side environment to access. However, you can run this code in a notebook to see the difference between the client and server working directories.</p>"},{"location":"tutorials/interacting-with-the-server/#synchronizing-client-and-server-side-stores","title":"Synchronizing client and server-side stores","text":"<p>In the last Sharing state tutorial, we saw how to create a store shared between components with <code>store = create_store(...)</code>. This store lives in the browser's memory, and is not accessible from the server. This means that once you have run your app, the <code>store</code> variable in your notebook will not be updated when the state in the browser is updated.</p> <p>Pret offers a simple way to synchronize this store object between the client and the server, by using the <code>sync</code> option in the <code>create_store</code> function. This option will keep both server and client states in sync whenever one of them is updated. Under the hood, the store is managed as a CRDT (Conflict-free Replicated Data Type) with Yjs and py-crdt, and only the changes are sent to the other side.</p> <pre><code>from pret_joy import Button\nfrom pret import component, create_store\nfrom pret.hooks import use_store_snapshot\n\nstore = create_store({\n    \"count\": 0,\n}, sync=True)\n\n\n@component\ndef Counter():\n    tracked = use_store_snapshot(store)\n\n    def increment(event):\n        store[\"count\"] += 1\n\n    return Button(\n        f\"Count: {tracked['count']}. Click to increment\",\n        on_click=increment,\n        sx={\"m\": 1},\n    )\n\n\nCounter()\n</code></pre> <p>In your notebook, you can now change the <code>store[\"count\"]</code> variable in another cell, and observe the change in the browser. Conversely, you can click the \"Increment\" button in the browser, and print the <code>store[\"count\"]</code> variable in your notebook to see the change.</p> <pre><code># Show the current count, synchronized with the browser\nprint(store[\"count\"])\n\n# Change the count from the notebook\nstore[\"count\"] = 42\n</code></pre>"},{"location":"tutorials/interacting-with-the-server/#persisting-the-store-to-the-file-system","title":"Persisting the store to the file system","text":"<p>Passing a file path to the <code>sync</code> option makes the store persistent across server restarts and enables collaboration even when several kernels run in different processes. Every update is appended to the file as a binary Yjs CRDT update. Each server watches the file for changes so that edits made by another process are picked up and broadcasted to its connected clients.</p> <pre><code>store = create_store({\"count\": 0}, sync=\"./shared_state.bin\")\n</code></pre> <p>If another instance of your application uses the same file path, all changes will be merged and synchronized between all clients and servers.</p>"},{"location":"tutorials/sharing-state/","title":"Sharing state","text":""},{"location":"tutorials/sharing-state/#sharing-state","title":"Sharing state","text":"<p>In the previous tutorial, we have seen how to compose a simple component from other components, how to render it, and detect user events. In this tutorial, we will see how to share state between components.</p>"},{"location":"tutorials/sharing-state/#the-state-management-problem","title":"The state management problem","text":"<p>Why is state management hard in web development? The dynamic nature of user interfaces means multiple components must reflect and react to shared and changing data without re-rendering everything anytime something changes (e.g, you recompute the whole app UI whenever a single state variable changes), or convoluted data flows (e.g., state being passed through many layers of components that don\u2019t even use it). Traditional approaches, like Redux, often introduce layers of boilerplate and require careful architecture when planning mutations on the app data.</p> <p>There is another issue of immutability: we cannot mutate the state directly (e.g., <code>state.todos[0][\"done\"] = True</code>), since React, and thus Pret, often relies on shallow comparison to detect changes in the state. For instance, if <code>todos</code> is the same object, even though its content has changed, some React utils (e.g. memo) will consider that the state has not changed and will not trigger a re-render.</p> <p>And if we take care of preventing direct mutations, changing the state can be cumbersome. For instance, if we want to change the <code>done</code> field of the first todo, we would have to do something like this:</p> <pre><code>new_todos = list(todos)\nnew_todos[0] = {**todos[0], \"done\": True}\n\n# We now have todos != new_todos and\n# todos[i] == new_todos[i] for all i except 0\n</code></pre>"},{"location":"tutorials/sharing-state/#prets-store-system","title":"Pret's store system","text":"<p>Pret provides a simple way to manage state in your components. A store, powered by Yjs and py-crdt, can be created and shared between components. Mutations to the state are made easy, and the app automatically knows which components should be re-rendered when a given part of the state changes.</p> <p>To create a store, we use the <code>create_store</code> wrapper:</p> <pre><code>from pret.store import create_store, subscribe\n\n\nstore = create_store(\n    {\n        \"todos\": [\n            {\"text\": \"My first todo\", \"done\": True},\n            {\"text\": \"My second todo\", \"done\": False},\n        ],\n        \"letters\": [\"a\", \"b\"],\n    }\n)\n\n\ndef on_event(ops):\n    for op in ops:\n        print(op.path, \"=&gt;\", op.keys if hasattr(op, \"keys\") else op.delta)\n\n\nsubscribe(store, callback=on_event)\nstore[\"todos\"][1][\"done\"] = True\n# Out: ['todos', 1] =&gt; {'done': {'action': 'update', 'oldValue': False, 'newValue': True}}\n\ndel store[\"todos\"][1][\"done\"]\n# Out: ['todos', 1] =&gt; {'done': {'action': 'delete', 'oldValue': True}}\n\nstore[\"todos\"][1][\"cool\"] = True\n# Out: ['todos', 1] =&gt; {'cool': {'action': 'add', 'newValue': True}}\n\nstore[\"letters\"].append(\"c\")\n# Out: ['letters'] =&gt; [{'retain': 2}, {'insert': ['c']}]\n\nstore[\"letters\"][1] = \"z\"\n# Out: ['letters'] =&gt; [{'retain': 1}, {'delete': 1}, {'insert': ['z']}]\n</code></pre> <p>Supported types</p> <p>At the moment, not all types can be used in a Pret store. We focus on supporting the most common container types, such as lists and dictionaries, in addition to the basic types (int, float, str, bool, None).</p>"},{"location":"tutorials/sharing-state/#using-stores-in-components","title":"Using stores in components","text":"<p>Now that we have a store object, we can use it in our components. To let Pret know that a component should re-render when a part of the state changes, we use the <code>use_store_snapshot</code> hook, which returns a snapshot of the state. This hook tracks access made on the state, and if a mutation on a part of the state that was accessed is detected :</p> <ul> <li>the component will re-render</li> <li>the snapshot will be different from the previous one (meaning, we don't have the <code>new_todos is todos</code> issue mentioned earlier)</li> </ul> <pre><code>from pret import component, use_store_snapshot, create_store\nfrom pret_joy import Checkbox, Stack\n\n\nstore = create_store({\n    \"todos\": [\n        {\"text\": \"My first todo\", \"done\": True},\n        {\"text\": \"My second todo\", \"done\": False},\n    ],\n})\n\n\n@component\ndef TodoList():  # (1)!\n    todos = use_store_snapshot(store[\"todos\"])\n\n    def on_change(event, i):\n        store[\"todos\"][i][\"done\"] = event.target.checked\n\n    return Stack(\n        [\n            Checkbox(\n                label=todo[\"text\"],\n                checked=todo[\"done\"],\n                on_change=lambda event, i=i: on_change(event, i),\n            )\n            for i, todo in enumerate(todos)\n        ],\n        spacing=2,\n        sx={\"m\": \"1em\"},\n    )\n\n\nTodoList()\n</code></pre> <ol> <li>Note that we don't pass the <code>todos</code> as an argument to the <code>TodoList</code> component anymore. Instead, we use the <code>use_store_snapshot</code> hook to directly subscribe to the global <code>store</code> object.</li> </ol>"},{"location":"tutorials/sharing-state/#sharing-state-between-components","title":"Sharing state between components","text":"<p>Sharing state between components is now straightforward. Let's display the number of remaining todos in the list. We will use the same <code>store</code> object as the component above.</p> <pre><code>from pret.react import br\nfrom pret_joy import Typography\n\n\n@component\ndef RemainingTodoCounter():\n    todos = use_store_snapshot(store[\"todos\"])\n    num_remaining = sum(not todo[\"done\"] for todo in todos)\n\n    return Typography(\n        f\"Number of unfinished todos: {num_remaining}.\",\n        br(),\n        \"Click todos in the previous component to change the count.\",\n        sx={\"m\": \"1em\"},\n    )\n\nRemainingTodoCounter()\n</code></pre>"},{"location":"tutorials/tictactoe/","title":"TicTacToe","text":""},{"location":"tutorials/tictactoe/#tictactoe","title":"TicTacToe","text":"<p>Let's build a simple TicTacToe game using Pret. We will build a simple game where two players can play against each other.</p> <pre><code>from pret import create_store, component\nfrom pret.hooks import use_store_snapshot\nfrom pret.react import button, div\n\nstate = create_store({\n    \"board\": [0] * 9,\n    \"turn\": 1,\n    \"winning_pattern\": [],\n})\n\nwinning_patterns = [\n    [0, 1, 2],\n    [3, 4, 5],\n    [6, 7, 8],\n    [0, 3, 6],\n    [1, 4, 7],\n    [2, 5, 8],\n    [0, 4, 8],\n    [6, 4, 2],\n]\n\nSQUARE_STYLE = {\n    \"display\": \"flex\",\n    \"justifyContent\": \"center\",\n    \"alignItems\": \"center\",\n    \"width\": \"60px\",\n    \"height\": \"60px\",\n    \"margin\": \"2px\",\n    \"fontSize\": \"24px\",\n    \"padding\": \"0\",\n    \"appearance\": \"none\",\n    \"border\": \"1px solid grey\",\n}\n\nWINNING_SQUARE_STYLE = {\n    **SQUARE_STYLE,\n    \"background\": \"lightGreen\",\n}\n\nGRID_STYLE = {\n    \"display\": \"grid\",\n    \"gridTemplateColumns\": \"repeat(3, 66px)\",\n    \"gridGap\": \"2px\",\n    \"margin\": \"1em 0\"\n}\n\n\n@component\ndef TicTacToe():\n    tracked = use_store_snapshot(state)\n    winning_pattern = tracked[\"winning_pattern\"]\n\n    def on_click_square(idx):\n        # if the game is over, clean everything on click\n        if bool(state[\"winning_pattern\"]) or 0 not in state[\"board\"]:\n            state[\"board\"][:] = [0 for _ in range(9)]\n            state[\"winning_pattern\"] = []\n            return\n\n        # place a piece on the board\n        value = state[\"board\"][idx]\n        if value == 0:\n            state[\"board\"][idx] = state[\"turn\"]\n        state[\"turn\"] = 2 if state[\"turn\"] == 1 else 1\n\n        # check for victory\n        for pattern in winning_patterns:\n            players = set(state[\"board\"][i] for i in pattern)\n            if len(players) == 1 and 0 not in players:\n                state[\"winning_pattern\"] = pattern\n\n    return div(\n        [\n            button(\n                \"X\" if square == 2 else \"O\" if square == 1 else \"\",\n                on_click=lambda event, idx=idx: on_click_square(idx),\n                style=(\n                    WINNING_SQUARE_STYLE if idx in winning_pattern else SQUARE_STYLE\n                ),\n            )\n            for idx, square in enumerate(tracked[\"board\"])\n        ],\n        style=GRID_STYLE,\n    )\n\n\nTicTacToe()\n</code></pre>"},{"location":"tutorials/widgets/","title":"Widgets","text":""},{"location":"tutorials/widgets/#widgets","title":"Widgets","text":"<p>Self-contained, interactive and controllable components.</p>"},{"location":"tutorials/widgets/#whats-a-widget","title":"What\u2019s a widget?","text":"<p>In Pret, a widget is a component that manages its own UI state, exposes a small imperative API (a \u201chandle\u201d) for commands like scroll to X or focus, and emits events (callbacks) when the user interacts with it. A widget runs on its own, without needing to be controlled by a parent component.</p> <p>In dashboards and multi-pane tools, panes often look at the same data from different angles but don\u2019t need to mirror each other\u2019s UI details (scroll positions, hovers, transient filters, typing...): this is where widgets shine, as they encapsulate their own UI state and logic.</p> <p>By contrast, a classic (controlled / presentational) component, such as AnnotatedText, keeps minimal or no state and expects its parent to hold all the UI logic and state and to pass it down as params.</p>"},{"location":"tutorials/widgets/#if-it-looks-like-a-widget-and-quacks-like-a-widget","title":"If it looks like a widget and quacks like a widget...","text":"<p>Widgets are not a formal class or type in Pret. They are just components that can run without being controlled by a parent. Just like any other component in Pret, widgets can be declared from inside a <code>@component</code> function (i.e., controlled by another component) or directly from your notebook/server. To interact with other parts of the UI, widgets expose two kinds of interfaces:</p>"},{"location":"tutorials/widgets/#1-events-callbacks","title":"1) Events (callbacks)","text":"<ul> <li>Notify when an event occurs: <code>on_change(id)</code>, <code>on_hover(id, ...)</code>, ...</li> <li>These are callbacks: they don\u2019t change other widgets directly.</li> </ul>"},{"location":"tutorials/widgets/#2-imperative-handle-commands","title":"2) Imperative handle (commands)","text":"<ul> <li>Let other parts of the UI command this widget: <code>handle.current.scroll_to_id(id)</code>, <code>handle.current.set_active(id)</code>, <code>handle.current.set_filter(key, value)</code>, ...</li> <li>These are UI actions and read-only getters like <code>handle.current.get_selection()</code>.</li> </ul> <p>Actions object</p> <p>In Pret, a common pattern is to pass a mutable <code>handle</code> Ref defined with use_ref that the widget fills: it writes callable entries under a <code>current</code> attribute, which the parent can then call imperatively.</p>"},{"location":"tutorials/widgets/#dos-and-donts","title":"Do's and don'ts","text":"<ul> <li> Don\u2019t wrap them in a stateful parent that is going to re-render often.</li> <li> Don't make them expect props that change with the app state (e.g., <code>value</code>).</li> <li> You can compose them in a layout/panel/div for presentational purposes.</li> <li> You can control them from the notebook or from other widgets through their <code>handle</code>.</li> </ul>"},{"location":"tutorials/widgets/#example","title":"Example","text":"<p>Our objective is to define a counter and a log that stand alone, and from the notebook decide if and how they talk to each other, without introducing a new \"controller\" (or \"App\") component. Controlled components (ie, non widgets components) push you to create a shared parent to pass props around. Widgets keep their own state, expose a small actions handle, and emit events so you can wire them together (or not) from the notebook.</p> <p>Let's create a <code>CounterWidget</code> that exposes <code>reset</code> / <code>set</code> commands and an <code>on_change</code> event, and a <code>LogWidget</code> that exposes an <code>add</code> command.</p> <pre><code>from pret import component\nfrom pret.hooks import use_event_callback, use_ref, use_state, use_imperative_handle\nfrom pret_joy import Button, Stack, Typography\n\n\n@component\ndef CounterWidget(handle=None, on_change=None):\n    count, set_count = use_state(0)\n\n    use_imperative_handle(\n        handle,\n        lambda: {\n            \"reset\": lambda: set_count(0),\n            \"set\": set_count,\n        },\n        [],\n    )\n\n    @use_event_callback\n    def increment():\n        def update(prev):\n            new_value = prev + 1\n            if on_change is not None:\n                on_change(new_value)\n            return new_value\n\n        set_count(update)\n\n    return Button(\n        f\"Count: {count}\",\n        on_click=increment,\n        spacing=1,\n        sx={\"minWidth\": 220, \"m\": 1},\n    )\n\n\n@component\ndef LogWidget(handle=None):\n    messages, set_messages = use_state([])\n\n    use_imperative_handle(\n        handle,\n        lambda: {\n            \"add\": lambda text: set_messages(lambda prev: [*prev, text]),\n            \"clear\": lambda: set_messages([]),\n        },\n        [],\n    )\n\n    return Stack(\n        [\n            Typography(\"Logs:\", level=\"body-md\"),\n            *[Typography(f\"- {msg}\", level=\"body-sm\") for msg in messages],\n        ],\n        spacing=1,\n        sx={\"minWidth\": 220, \"m\": 1},\n    )\n</code></pre> <p>Let's render the counter widget in a cell:</p> <pre><code># remote refs to hold the counter actions\ncounter_handle = use_ref()\nlog_handle = use_ref()\n\nCounterWidget(\n    handle=counter_handle,\n    on_change=lambda v: log_handle.current.add(f\"Counter is now {v}\"),\n)\n</code></pre> <p>Then the log widget in another cell:</p> <pre><code>LogWidget(handle=log_handle)\n</code></pre> <p>Finally the reset button in another cell:</p> <pre><code>Button(\n    \"Reset counter\",\n    on_click=lambda: counter_handle.current.reset(),\n    color=\"neutral\", variant=\"outlined\",\n    sx={\"minWidth\": 220, \"m\": 1},\n)\n</code></pre> <p>We could also have everything in the same cell using a <code>Stack</code> or <code>Grid</code> layout.</p> <p>You can observe that no UI state is shared between the two widgets: they talk and synchronize through events and commands.</p>"},{"location":"tutorials/widgets/#remote-refs","title":"Remote refs","text":"<p>In the example above, we created two <code>use_ref()</code> references in the notebook to hold the handles of the two widgets. When these refs are created in the notebook, they are called remote refs because they are created on the server side and allow to control widgets running on the client side. <code>use_ref</code> is the only hook that can be used outside of a <code>@component</code> function, i.e., directly in the notebook.</p> <p>One advantage of this is that, should you refactor your app and move the widget creation from the notebook to a component, and the remote ref to a standard local ref, you just have to move everything in a <code>@component</code> function, and it should work like a charm.</p> <p>However, this comes with a few limitations :</p> <ul> <li>you can only interact with fields on the handle that are functions (e.g.,  <code>handle.current.focus()</code>), not properties (e.g.,  <code>handle.current.value</code>).</li> <li>calling functions on remote refs is asynchronous, and the result is a future/promise. You cannot expect to get a return value immediately.</li> </ul>"},{"location":"tutorials/widgets/#widget-factories","title":"Widget factories","text":"<p>As explained above, widgets are just components that follow some conventions. They should therefore not require access to the server/kernel state to be rendered. You may still need to configure a widget with some data from the server. This is where widget factories come in handy: a widget factory is a function that takes runs on the server and returns a Renderable widget that can be embedded in a Pret app.</p> <p>For instance, imagine a <code>DataFrame</code> widget that displays the content of a pandas DataFrame. DataFrame are not serializable, so the widget cannot directly use a dataframe during its rendering. Instead, we can create a widget factory that takes a DataFrame, prepares the data (e.g., serializes it to JSON) and returns a Table configured with this data.</p> <p>Observe how the factory function <code>DataFrameComponentFactory</code> is not decorated with <code>@component</code>: it is instead meant to run on the server and return a widget, which in turn can be rendered on the client.</p> <p>Here is a component factory that takes a pandas DataFrame and returns a Table Renderable element:</p> <pre><code>import pandas as pd\nfrom pret.render import Renderable\nfrom metanno import Table\n\n\ndef DataFrameStaticViewFactory(df: pd.DataFrame, editable_columns=[]) -&gt; Renderable:\n    # Prepare the data (e.g., serialize to JSON)\n    data = df.to_dict(orient=\"records\")\n    columns = [\n        {\n            \"name\": col,\n            \"key\": col,\n            \"filterable\": True,\n            \"kind\": \"text\"\n            if df.dtypes[col].kind in \"iufc\"\n            else \"boolean\"\n            if df.dtypes[col].kind == \"b\"\n            else \"text\",\n            \"editable\": col in editable_columns,\n        }\n        for col in df.columns\n    ]\n\n    # Return a Table component configured with the data\n    return Table(rows=data, columns=columns)\n</code></pre> <p>Note that since Table expects the data to be prepared and updated for it by its caller (i.e., it is a controlled component), we have no way make this component dynamic.</p> <p>Now, here is a widget factory that takes a DataFrame and returns a configurable metanno Table widget. It will expose an imperative API to set/get filters and scroll to a given row and an event callback when a cell is changed:</p> <pre><code>import pandas as pd\nfrom pret.render import Renderable, component\nfrom pret.hooks import use_event_callback, use_imperative_handle, use_ref, use_state\nfrom pret import server_only\nfrom metanno import Table\n\n\ndef DataFrameWidgetFactory(\n    df: pd.DataFrame, handle=None, editable_columns=[]\n) -&gt; Renderable:\n    # Prepare the data (e.g., serialize to JSON)\n    data = df.to_dict(orient=\"records\")\n    columns = [\n        {\n            \"name\": col,\n            \"key\": col,\n            \"filterable\": True,\n            \"kind\": \"text\"\n            if df.dtypes[col].kind in \"iufc\"\n            else \"boolean\"\n            if df.dtypes[col].kind == \"b\"\n            else \"text\",\n            \"editable\": col in editable_columns,\n        }\n        for col in df.columns\n    ]\n\n    @server_only\n    def handle_cell_change_server(row_idx, col_key, new_value):\n        df.at[row_idx, col_key] = new_value\n\n    @component\n    def Widget(handle=None, on_cell_change=None) -&gt; Renderable:\n        # Internal state\n        filters, set_filters = use_state({})\n        table_handle = use_ref()\n        state_data, set_state_data = use_state(data)\n\n        use_imperative_handle(\n            handle,\n            lambda: {\n                \"set_filters\": set_filters,\n                \"get_filters\": lambda: filters,\n                \"scroll_to_row\": lambda idx, behavior=None: table_handle.current.scroll_to_row(\n                    idx, behavior\n                ),\n            },\n            [],\n        )\n\n        @use_event_callback\n        def handle_filters_change(filters, col):\n            set_filters(filters)\n\n        @use_event_callback\n        def handle_cell_change(row_idx, col_key, new_value):\n            # Update local state to reflect the change\n            updated_data = list(state_data)\n            updated_data[row_idx] = {**updated_data[row_idx], col_key: new_value}\n            set_state_data(updated_data)\n            if on_cell_change is not None:\n                on_cell_change(row_idx, col_key, new_value)\n\n        # Return a Table component configured with the data and event handlers\n        return Table(\n            rows=state_data,\n            columns=columns,\n            filters=filters,\n            auto_filter=True,\n            on_filters_change=set_filters,\n            on_cell_change=handle_cell_change,\n            handle=table_handle,\n            style={\"height\": \"200px\"},\n        )\n\n    return Widget(handle=handle, on_cell_change=handle_cell_change_server)\n</code></pre> <p>You can now use it by first creating a reference to hold the widget handle, then creating the widget using the factory, and finally rendering it:</p> <pre><code>df = pd.DataFrame([{\"a\": i, \"check\": False} for i in range(100)])\nhandle = use_ref()\nDataFrameWidgetFactory(df, handle=handle)\n</code></pre> <p>Again : like widgets, a widget factory merely a code pattern: it is a function that runs on the server and returns a Renderable widget that can be rendered and controlled from the outside. Note how changing a cell in the table updates the underlying DataFrame on the server side. You can also control it imperatively by running the following code in another cell:</p> <pre><code># Scroll to row 50\nhandle.current.scroll_to_row(50)\n</code></pre> <p>or from a button:</p> <pre><code>from pret_joy import Button\n\nButton(\n    \"Go to row 50\",\n    on_click=lambda: handle.current.scroll_to_row(50),\n    sx={\"m\": 1},\n)\n</code></pre>"},{"location":"reference/pret/","title":"<code>pret</code>","text":""},{"location":"reference/pret/#pret.run","title":"<code>run</code>","text":"<p>Serve the app, after building the app if necessary.</p>"},{"location":"reference/pret/#pret.run--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>renderable</code> <p>The renderable object to be served</p> <p> </p> <code>static_dir</code> <p>The directory where the static files will be stored</p> <p> TYPE: <code>Optional[Union[str, Path]]</code> DEFAULT: <code>None</code> </p> <code>build_dir</code> <p>The directory where the build files will be stored</p> <p> TYPE: <code>Optional[Union[str, Path]]</code> DEFAULT: <code>None</code> </p> <code>bundle</code> <p>The mode to use for bundling :</p> <ul> <li>\"federated\": The app will be bundled where the assets are   just copied from each package. This means that there may   be repeated assets in the final bundle.</li> <li>\"monolithic\": The app will be bundled where a consolidated   bundle is created with all the assets, using webpack.</li> </ul> <p>By default, the mode is \"federated\".</p> <p> TYPE: <code>Union[bool, str, BundleMode]</code> DEFAULT: <code>True</code> </p> <code>dev</code> <p>Only used when mode is \"monolithic\". If True, the bundle will be created in development mode. Otherwise, it will be created in production mode.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>serve</code> <p>Whether to serve the app after building it.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>port</code> <p>The port to use for serving the app.</p> <p> TYPE: <code>int</code> DEFAULT: <code>5000</code> </p> <code>host</code> <p>The host to use for serving the app.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p>"},{"location":"reference/pret/#pret.component","title":"<code>component</code>","text":"<p>Decorator to turn a Python function into a Pret component, that will be rendered by React.</p>"},{"location":"reference/pret/#pret.component--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>fn</code> <p> TYPE: <code>Callable</code> </p>"},{"location":"reference/pret/#pret.create_store","title":"<code>create_store</code>","text":"<p>Create a new store that can be used to store and synchronize data between various components of the app, between a server and its clients, or between different processes (or across multiple runs of the app) using a file.</p>"},{"location":"reference/pret/#pret.create_store--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>data</code> <p>Initial data to store in the document. It can be a dictionary, list, or any simple value.</p> <p> </p> <code>sync</code> <p>There are three options for this parameter:</p> <ul> <li>If false, this store will not be synchronized between a server and its   clients. This can be useful for local-only stores, like style management.</li> <li>If true, the store will be synchronized between a server and its clients.   Any changes made to the store will be sent to the server and vice versa.</li> <li>If a path is provided, the store will be synchronized with the file at this   path. Any changes made to the store will be written to the file, and any   changes made to the file will be read into the store. This can be useful   if you want to persist the store to disk or share it between different   processes (think servers or kernels).</li> </ul> <p> TYPE: <code>Optional[Union[bool, str, PathLike]]</code> DEFAULT: <code>None</code> </p>"},{"location":"reference/pret/#pret.use_callback","title":"<code>use_callback</code>","text":"<p>Returns a memoized callback function. The callback will be stable across re-renders, as long as the dependencies don't change, meaning the last callback function passed to this function will be used between two re-renders.</p>"},{"location":"reference/pret/#pret.use_callback--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>callback</code> <p>The callback function</p> <p> TYPE: <code>C</code> </p> <code>dependencies</code> <p>The dependencies that will trigger a re-assignment of the callback.</p> <p> TYPE: <code>Optional[List]</code> DEFAULT: <code>None</code> </p>"},{"location":"reference/pret/#pret.use_callback--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>callback</code> <p>The callback function</p> <p> TYPE: <code>C</code> </p>"},{"location":"reference/pret/#pret.use_effect","title":"<code>use_effect</code>","text":"<p>The <code>useEffect</code> hook allows you to perform side effects in function components. Side effects can include data fetching, subscriptions, manually changing the DOM, and more.</p> <p>The effect runs after every render by default. If <code>dependencies</code> are provided, the effect runs whenever those values change. Therefore, if <code>dependencies</code> is an empty array, the effect runs only once after the initial render.</p>"},{"location":"reference/pret/#pret.use_effect--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>effect</code> <p>A function containing the side effect logic. It can optionally return a cleanup function.</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>None</code> </p> <code>dependencies</code> <p>An optional array of dependencies that determines when the effect runs.</p> <p> TYPE: <code>Optional[List]</code> DEFAULT: <code>None</code> </p>"},{"location":"reference/pret/#pret.use_imperative_handle","title":"<code>use_imperative_handle</code>","text":"<p>Safely binds a custom value or API to a parent's ref.</p> <p>Unlike manually setting <code>ref.current</code>, this hook automatically handles the lifecycle: it updates the ref when dependencies change and cleans it up (resets it to <code>None</code>) when the component unmounts.</p> <p>Use this to expose specific methods (like <code>focus</code> or <code>reset</code>) to a parent, rather than giving them direct access to internal DOM nodes.</p>"},{"location":"reference/pret/#pret.use_imperative_handle--example","title":"Example","text":"<pre><code>from pret import component, use_ref, use_imperative_handle\nfrom pret.react import button, div, input\n\n\n@component\ndef CustomInput(handle):\n    # 1. The internal ref connects to the actual DOM element\n    internal_input_ref = use_ref(None)\n\n    # 2. We define what the parent is allowed to see/do and attach\n    # that API to the handle passed down from the parent\n    use_imperative_handle(\n        handle,\n        lambda: {\n            \"reset_and_focus\": lambda: (\n                setattr(internal_input_ref.current, \"value\", \"\"),\n                internal_input_ref.current.focus(),\n            )\n        },\n        [],\n    )\n\n    return input(placeholder=\"Type here...\", ref=internal_input_ref)\n\n\n@component\ndef App():\n    # The parent creates a ref\n    input_controller = use_ref(None)\n\n    def on_click(event):\n        # The parent calls the custom method defined in the child\n        input_controller.current.reset_and_focus()\n\n    return div(\n        # Pass the ref as a regular prop named 'handle'\n        CustomInput(handle=input_controller),\n        button(\"Reset Form\", onClick=on_click),\n    )\n</code></pre> <p>Visit the Widgets tutorial to learn more about using <code>use_imperative_handle</code> in Pret.</p>"},{"location":"reference/pret/#pret.use_imperative_handle--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>ref</code> <p>The ref object passed in from the parent component (via a prop).</p> <p> TYPE: <code>Optional[RefType[T]]</code> </p> <code>create_handle</code> <p>A function that returns the custom object/API to be assigned to <code>ref.current</code>.</p> <p> TYPE: <code>Callable[[], T]</code> </p> <code>dependencies</code> <p>Optional dependencies. If these change, the handle is re-created.</p> <p> TYPE: <code>Optional[List]</code> DEFAULT: <code>None</code> </p>"},{"location":"reference/pret/#pret.use_memo","title":"<code>use_memo</code>","text":"<p>Returns a memoized value, computed from the provided function. The function will only be re-executed if any of the dependencies change.</p>"},{"location":"reference/pret/#pret.use_memo--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>fn</code> <p>The function to run to compute the memoized value</p> <p> TYPE: <code>Callable[[], T]</code> </p> <code>dependencies</code> <p>The dependencies that will trigger a re-execution of the function</p> <p> TYPE: <code>List</code> </p> RETURNS DESCRIPTION <code>FunctionReturnType</code> <p>The value</p>"},{"location":"reference/pret/#pret.use_ref","title":"<code>use_ref</code>","text":"<p>Returns a mutable ref object whose <code>.current</code> property is initialized to the passed argument.</p> <p>The returned object will persist for the full lifetime of the component.</p> <p>If called from the Python kernel/server side, it will create a RemoteRef object, which can only be used to call methods/getters on the remote ref (no property access) and get the results as futures.</p> <p>Visit the Widgets tutorial to learn more about using refs in Pret.</p> <p><code>current</code> Property</p> <p>Because refs are mutable containers whose contents can change without causing re-renders, React stores the actual value in a .current property so the ref object itself stays stable while its contents update freely.</p> <p>To keep this behavior consistent between server and client side calls to <code>use_ref</code>, the value of a ref is always accessed through the <code>.current</code> property.</p>"},{"location":"reference/pret/#pret.use_ref--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>initial_value</code> <p>The initial value of the ref</p> <p> TYPE: <code>T</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>RefType[T]</code> <p>The ref object</p>"},{"location":"reference/pret/#pret.use_state","title":"<code>use_state</code>","text":"<p>Returns a stateful value, and a function to update it.</p>"},{"location":"reference/pret/#pret.use_state--examples","title":"Examples","text":"<pre><code>from pret import component, use_state\nfrom pret.react import div, button, p\n\n\n@component\ndef CounterApp():\n    count, set_count = use_state(0)\n\n    def increment():\n        set_count(count + 1)\n\n    return div(p(count), button({\"onClick\": increment}, \"Increment\"))\n</code></pre>"},{"location":"reference/pret/#pret.use_state--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>initial_value</code> <p>The initial value of the state</p> <p> TYPE: <code>T</code> </p> RETURNS DESCRIPTION <code>Tuple[StateValueType, Callable[[StateValueType], None]]</code> <ul> <li>The current value of the state</li> <li>A function to update the state</li> </ul>"},{"location":"reference/pret/#pret.use_store_snapshot","title":"<code>use_store_snapshot</code>","text":"<p>This hook is used to track the access made on a store. You cannot use the returned object to change the store, you must mutate the original create_store(...) object directly.</p>"},{"location":"reference/pret/#pret.use_store_snapshot--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>proxy_object</code> <p>A store object, like the one returned by <code>create_store({...})</code></p> <p> </p> RETURNS DESCRIPTION <code>TrackedProxyType</code> <p>A tracked store object</p>"},{"location":"reference/pret/#pret.use_event_callback","title":"<code>use_event_callback</code>","text":"<p>This hook is used to store a callback function that will be called when an event is triggered. The callback function can be changed without triggering a re-render of the component. The function returns a wrapped callback function that will in turn call the stored callback function.</p> <p>Warning</p> <p>Do not use this hook if the rendering of the component depends on the callback function.</p>"},{"location":"reference/pret/#pret.use_event_callback--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>callback</code> <p>The callback function</p> <p> TYPE: <code>C</code> </p>"},{"location":"reference/pret/cli/","title":"<code>pret.cli</code>","text":""},{"location":"reference/pret/cli/prepack_command/","title":"<code>pret.cli.prepack_command</code>","text":""},{"location":"reference/pret/cli/prepack_command/#pret.cli.prepack_command.prepack","title":"<code>prepack</code>","text":"<p>Pre-packs a stub module into a single javascript file.</p>"},{"location":"reference/pret/cli/prepack_command/#pret.cli.prepack_command.prepack--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>stub_module</code> <p>The name of the stub module to prepack.</p> <p> TYPE: <code>str</code> </p> <code>output_path</code> <p>The path to the output file.</p> <p> TYPE: <code>str</code> </p> <code>cwd</code> <p>Whether to add the current working directory to the python path.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p>"},{"location":"reference/pret/cli/stub_command/","title":"<code>pret.cli.stub_command</code>","text":""},{"location":"reference/pret/cli/update_jupyter_config/","title":"<code>pret.cli.update_jupyter_config</code>","text":""},{"location":"reference/pret/cli/update_jupyter_config/#pret.cli.update_jupyter_config.find_home_config_dir","title":"<code>find_home_config_dir</code>","text":"<p>Choose a config directory that lives in the user's HOME (e.g. ~/.jupyter), not inside the active conda environment.</p>"},{"location":"reference/pret/cli/update_jupyter_config/#pret.cli.update_jupyter_config.env_labextensions_dir","title":"<code>env_labextensions_dir</code>","text":"<p>Compute /share/jupyter/labextensions for the active environment."},{"location":"reference/pret/cli/update_jupyter_config/#pret.cli.update_jupyter_config.set_extra_labextensions_path","title":"<code>set_extra_labextensions_path</code>","text":"<p>Create or update jupyter_server_config.py to set:   c.LabServerApp.extra_labextensions_path = [\"\", ...] If a previous assignment exists, replace it, otherwise append. Returns a tuple of (old_line, new_line, backup_path) where backup_path is the path to the backup file if created."},{"location":"reference/pret/hooks/","title":"<code>pret.hooks</code>","text":""},{"location":"reference/pret/hooks/#pret.hooks.use_state","title":"<code>use_state</code>","text":"<p>Returns a stateful value, and a function to update it.</p>"},{"location":"reference/pret/hooks/#pret.hooks.use_state--examples","title":"Examples","text":"<pre><code>from pret import component, use_state\nfrom pret.react import div, button, p\n\n\n@component\ndef CounterApp():\n    count, set_count = use_state(0)\n\n    def increment():\n        set_count(count + 1)\n\n    return div(p(count), button({\"onClick\": increment}, \"Increment\"))\n</code></pre>"},{"location":"reference/pret/hooks/#pret.hooks.use_state--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>initial_value</code> <p>The initial value of the state</p> <p> TYPE: <code>T</code> </p> RETURNS DESCRIPTION <code>Tuple[StateValueType, Callable[[StateValueType], None]]</code> <ul> <li>The current value of the state</li> <li>A function to update the state</li> </ul>"},{"location":"reference/pret/hooks/#pret.hooks.use_memo","title":"<code>use_memo</code>","text":"<p>Returns a memoized value, computed from the provided function. The function will only be re-executed if any of the dependencies change.</p>"},{"location":"reference/pret/hooks/#pret.hooks.use_memo--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>fn</code> <p>The function to run to compute the memoized value</p> <p> TYPE: <code>Callable[[], T]</code> </p> <code>dependencies</code> <p>The dependencies that will trigger a re-execution of the function</p> <p> TYPE: <code>List</code> </p> RETURNS DESCRIPTION <code>FunctionReturnType</code> <p>The value</p>"},{"location":"reference/pret/hooks/#pret.hooks.use_ref","title":"<code>use_ref</code>","text":"<p>Returns a mutable ref object whose <code>.current</code> property is initialized to the passed argument.</p> <p>The returned object will persist for the full lifetime of the component.</p> <p>If called from the Python kernel/server side, it will create a RemoteRef object, which can only be used to call methods/getters on the remote ref (no property access) and get the results as futures.</p> <p>Visit the Widgets tutorial to learn more about using refs in Pret.</p> <p><code>current</code> Property</p> <p>Because refs are mutable containers whose contents can change without causing re-renders, React stores the actual value in a .current property so the ref object itself stays stable while its contents update freely.</p> <p>To keep this behavior consistent between server and client side calls to <code>use_ref</code>, the value of a ref is always accessed through the <code>.current</code> property.</p>"},{"location":"reference/pret/hooks/#pret.hooks.use_ref--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>initial_value</code> <p>The initial value of the ref</p> <p> TYPE: <code>T</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>RefType[T]</code> <p>The ref object</p>"},{"location":"reference/pret/hooks/#pret.hooks.use_imperative_handle","title":"<code>use_imperative_handle</code>","text":"<p>Safely binds a custom value or API to a parent's ref.</p> <p>Unlike manually setting <code>ref.current</code>, this hook automatically handles the lifecycle: it updates the ref when dependencies change and cleans it up (resets it to <code>None</code>) when the component unmounts.</p> <p>Use this to expose specific methods (like <code>focus</code> or <code>reset</code>) to a parent, rather than giving them direct access to internal DOM nodes.</p>"},{"location":"reference/pret/hooks/#pret.hooks.use_imperative_handle--example","title":"Example","text":"<pre><code>from pret import component, use_ref, use_imperative_handle\nfrom pret.react import button, div, input\n\n\n@component\ndef CustomInput(handle):\n    # 1. The internal ref connects to the actual DOM element\n    internal_input_ref = use_ref(None)\n\n    # 2. We define what the parent is allowed to see/do and attach\n    # that API to the handle passed down from the parent\n    use_imperative_handle(\n        handle,\n        lambda: {\n            \"reset_and_focus\": lambda: (\n                setattr(internal_input_ref.current, \"value\", \"\"),\n                internal_input_ref.current.focus(),\n            )\n        },\n        [],\n    )\n\n    return input(placeholder=\"Type here...\", ref=internal_input_ref)\n\n\n@component\ndef App():\n    # The parent creates a ref\n    input_controller = use_ref(None)\n\n    def on_click(event):\n        # The parent calls the custom method defined in the child\n        input_controller.current.reset_and_focus()\n\n    return div(\n        # Pass the ref as a regular prop named 'handle'\n        CustomInput(handle=input_controller),\n        button(\"Reset Form\", onClick=on_click),\n    )\n</code></pre> <p>Visit the Widgets tutorial to learn more about using <code>use_imperative_handle</code> in Pret.</p>"},{"location":"reference/pret/hooks/#pret.hooks.use_imperative_handle--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>ref</code> <p>The ref object passed in from the parent component (via a prop).</p> <p> TYPE: <code>Optional[RefType[T]]</code> </p> <code>create_handle</code> <p>A function that returns the custom object/API to be assigned to <code>ref.current</code>.</p> <p> TYPE: <code>Callable[[], T]</code> </p> <code>dependencies</code> <p>Optional dependencies. If these change, the handle is re-created.</p> <p> TYPE: <code>Optional[List]</code> DEFAULT: <code>None</code> </p>"},{"location":"reference/pret/hooks/#pret.hooks.use_callback","title":"<code>use_callback</code>","text":"<p>Returns a memoized callback function. The callback will be stable across re-renders, as long as the dependencies don't change, meaning the last callback function passed to this function will be used between two re-renders.</p>"},{"location":"reference/pret/hooks/#pret.hooks.use_callback--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>callback</code> <p>The callback function</p> <p> TYPE: <code>C</code> </p> <code>dependencies</code> <p>The dependencies that will trigger a re-assignment of the callback.</p> <p> TYPE: <code>Optional[List]</code> DEFAULT: <code>None</code> </p>"},{"location":"reference/pret/hooks/#pret.hooks.use_callback--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>callback</code> <p>The callback function</p> <p> TYPE: <code>C</code> </p>"},{"location":"reference/pret/hooks/#pret.hooks.use_effect","title":"<code>use_effect</code>","text":"<p>The <code>useEffect</code> hook allows you to perform side effects in function components. Side effects can include data fetching, subscriptions, manually changing the DOM, and more.</p> <p>The effect runs after every render by default. If <code>dependencies</code> are provided, the effect runs whenever those values change. Therefore, if <code>dependencies</code> is an empty array, the effect runs only once after the initial render.</p>"},{"location":"reference/pret/hooks/#pret.hooks.use_effect--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>effect</code> <p>A function containing the side effect logic. It can optionally return a cleanup function.</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>None</code> </p> <code>dependencies</code> <p>An optional array of dependencies that determines when the effect runs.</p> <p> TYPE: <code>Optional[List]</code> DEFAULT: <code>None</code> </p>"},{"location":"reference/pret/hooks/#pret.hooks.use_store_snapshot","title":"<code>use_store_snapshot</code>","text":"<p>This hook is used to track the access made on a store. You cannot use the returned object to change the store, you must mutate the original create_store(...) object directly.</p>"},{"location":"reference/pret/hooks/#pret.hooks.use_store_snapshot--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>proxy_object</code> <p>A store object, like the one returned by <code>create_store({...})</code></p> <p> </p> RETURNS DESCRIPTION <code>TrackedProxyType</code> <p>A tracked store object</p>"},{"location":"reference/pret/hooks/#pret.hooks.use_event_callback","title":"<code>use_event_callback</code>","text":"<p>This hook is used to store a callback function that will be called when an event is triggered. The callback function can be changed without triggering a re-render of the component. The function returns a wrapped callback function that will in turn call the stored callback function.</p> <p>Warning</p> <p>Do not use this hook if the rendering of the component depends on the callback function.</p>"},{"location":"reference/pret/hooks/#pret.hooks.use_event_callback--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>callback</code> <p>The callback function</p> <p> TYPE: <code>C</code> </p>"},{"location":"reference/pret/ipython_var_cleaner/","title":"<code>pret.ipython_var_cleaner</code>","text":""},{"location":"reference/pret/main/","title":"<code>pret.main</code>","text":""},{"location":"reference/pret/main/#pret.main.build","title":"<code>build</code>","text":"<p>Build the Pret app, pooling all the assets and entry points from the packages that were accessed for rendering.</p>"},{"location":"reference/pret/main/#pret.main.build--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>renderables</code> <p>The list of renderables to be bundled</p> <p> </p> <code>static_dir</code> <p>The directory where the static files will be stored</p> <p> TYPE: <code>Union[str, Path]</code> DEFAULT: <code>None</code> </p> <code>build_dir</code> <p>The directory where the build files will be stored</p> <p> TYPE: <code>Union[str, Path]</code> DEFAULT: <code>None</code> </p> <code>mode</code> <p>The mode to use for bundling :</p> <ul> <li>\"federated\": The app will be bundled where the assets are   just copied from each package. This means that there may   be repeated assets in the final bundle.</li> <li>\"monolithic\": The app will be bundled where a consolidated   bundle is created with all the assets, using webpack.</li> </ul> <p>By default, the mode is \"federated\".</p> <p> TYPE: <code>Union[bool, str, BundleMode]</code> DEFAULT: <code>True</code> </p> <code>dev</code> <p>Only used when mode is \"monolithic\". If True, the bundle will be created in development mode. Otherwise, it will be created in production mode.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Tuple[Dict[str, Union[str, Path]], List[Tuple[str, str]], str]</code> <p>A tuple containing the assets, entries and pickle filename</p>"},{"location":"reference/pret/main/#pret.main.extract_js_dependencies","title":"<code>extract_js_dependencies</code>","text":"<p>Create a js file that will import all the globals that were accessed during pickling and assign them to the global scope.</p>"},{"location":"reference/pret/main/#pret.main.extract_js_dependencies--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>refs</code> <p>List of Ref objects that were accessed during pickling</p> <p> </p> <code>exclude</code> <p>List of module patterns to exclude from the js globals file</p> <p> DEFAULT: <code>('js.React.*', 'js.ReactDOM.*')</code> </p>"},{"location":"reference/pret/main/#pret.main.extract_prebuilt_extension_assets","title":"<code>extract_prebuilt_extension_assets</code>","text":"<p>Extracts entry javascript files from the static directory of each package as well as a mapping entry -&gt; file to know where to look for whenever the app asks for a chunk or an asset.</p>"},{"location":"reference/pret/main/#pret.main.extract_prebuilt_extension_assets--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>packages</code> <p> TYPE: <code>List[str]</code> </p> RETURNS DESCRIPTION <code>Tuple[Dict[str, Path], List[Tuple[str, str]]]</code>"},{"location":"reference/pret/main/#pret.main.extract_prebuilt_base_assets","title":"<code>extract_prebuilt_base_assets</code>","text":"<p>Extracts the base index.html file as well as a mapping entry -&gt; file to know where to look for whenever the app asks for a chunk or an asset.</p>"},{"location":"reference/pret/main/#pret.main.extract_prebuilt_base_assets--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>Returns</code> <code>Tuple</code>"},{"location":"reference/pret/main/#pret.main.run","title":"<code>run</code>","text":"<p>Serve the app, after building the app if necessary.</p>"},{"location":"reference/pret/main/#pret.main.run--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>renderable</code> <p>The renderable object to be served</p> <p> </p> <code>static_dir</code> <p>The directory where the static files will be stored</p> <p> TYPE: <code>Optional[Union[str, Path]]</code> DEFAULT: <code>None</code> </p> <code>build_dir</code> <p>The directory where the build files will be stored</p> <p> TYPE: <code>Optional[Union[str, Path]]</code> DEFAULT: <code>None</code> </p> <code>bundle</code> <p>The mode to use for bundling :</p> <ul> <li>\"federated\": The app will be bundled where the assets are   just copied from each package. This means that there may   be repeated assets in the final bundle.</li> <li>\"monolithic\": The app will be bundled where a consolidated   bundle is created with all the assets, using webpack.</li> </ul> <p>By default, the mode is \"federated\".</p> <p> TYPE: <code>Union[bool, str, BundleMode]</code> DEFAULT: <code>True</code> </p> <code>dev</code> <p>Only used when mode is \"monolithic\". If True, the bundle will be created in development mode. Otherwise, it will be created in production mode.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>serve</code> <p>Whether to serve the app after building it.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>port</code> <p>The port to use for serving the app.</p> <p> TYPE: <code>int</code> DEFAULT: <code>5000</code> </p> <code>host</code> <p>The host to use for serving the app.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p>"},{"location":"reference/pret/manager/","title":"<code>pret.manager</code>","text":"<p>This module provides client and server managers for handling remote calls, state synchronization, and communication between the frontend and backend.</p>"},{"location":"reference/pret/manager/#pret.manager.JupyterClientManager","title":"<code>JupyterClientManager</code>","text":"<p>           Bases: <code>Manager</code></p>"},{"location":"reference/pret/manager/#pret.manager.JupyterClientManager.handle_comm_message","title":"<code>handle_comm_message</code>  <code>async</code>","text":"<p>Called when a message is received from the front-end</p>"},{"location":"reference/pret/manager/#pret.manager.JupyterServerManager","title":"<code>JupyterServerManager</code>","text":"<p>           Bases: <code>Manager</code></p>"},{"location":"reference/pret/manager/#pret.manager.JupyterServerManager.close","title":"<code>close</code>","text":"<p>Close method. Closes the underlying comm. When the comm is closed, all the view views are automatically removed from the front-end.</p>"},{"location":"reference/pret/manager/#pret.manager.JupyterServerManager.handle_comm_msg","title":"<code>handle_comm_msg</code>","text":"<p>Called when a message is received from the front-end</p>"},{"location":"reference/pret/manager/#pret.manager.StandaloneClientManager","title":"<code>StandaloneClientManager</code>","text":"<p>           Bases: <code>Manager</code></p>"},{"location":"reference/pret/manager/#pret.manager.is_awaitable","title":"<code>is_awaitable</code>","text":"<p>If the value is an awaitable, await it, otherwise return the value.</p>"},{"location":"reference/pret/manager/#pret.manager.start_async_task","title":"<code>start_async_task</code>","text":"<p>Start an async task and return it.</p>"},{"location":"reference/pret/manager/#pret.manager.b64_encode","title":"<code>b64_encode</code>","text":"<p>Encode bytes to a base64 string.</p>"},{"location":"reference/pret/manager/#pret.manager.b64_decode","title":"<code>b64_decode</code>","text":"<p>Decode a base64 string to bytes.</p>"},{"location":"reference/pret/marshal/","title":"<code>pret.marshal</code>","text":"<p>This module provides marshaling to convert Python objects (and functions, and classes) into a format that can be serialized and later reconstructed in a JavaScript environment.</p>"},{"location":"reference/pret/react/","title":"<code>pret.react</code>","text":""},{"location":"reference/pret/render/","title":"<code>pret.render</code>","text":"<p>This module provides helpers to create React components from Python functions, and to create components from existing React components. Any component is made renderable in Jupyter by wrapping it in a <code>Renderable</code> object when called from Python.</p>"},{"location":"reference/pret/render/#pret.render.Renderable","title":"<code>Renderable</code>","text":"<p>A Renderable is the blueprint for a React component that can be rendered in a Jupyter notebook. When Jupyter sees it (for instance you call <code>display()</code> on it), or it is the result of the last expression in a cell, it will send the (transpiled) app code and app state to the frontend, which will then render using React.</p> <p>When multiple Renderables are sent to the frontend, we try to deduplicate the code and data sent, by using a shared persisted marshaler. When facing rendering issues, don't hesitate to restart the kernel, clear the cells and reload the page.</p>"},{"location":"reference/pret/render/#pret.render.make_create_element_from_function","title":"<code>make_create_element_from_function</code>","text":"<p>Turn a Python Pret function into function that creates a React element.</p>"},{"location":"reference/pret/render/#pret.render.make_create_element_from_function--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>fn</code> <p>The Python function to turn into a React element creator, ie a function that when invoked by React, will call the Python function with the correct arguments.</p> <p> </p> RETURNS DESCRIPTION <code>(**props) -&gt; ReactElement&lt;fn</code>"},{"location":"reference/pret/render/#pret.render.component","title":"<code>component</code>","text":"<p>Decorator to turn a Python function into a Pret component, that will be rendered by React.</p>"},{"location":"reference/pret/render/#pret.render.component--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>fn</code> <p> TYPE: <code>Callable</code> </p>"},{"location":"reference/pret/routing/","title":"<code>pret.routing</code>","text":""},{"location":"reference/pret/routing/#pret.routing.Routes","title":"<code>Routes</code>","text":""},{"location":"reference/pret/routing/#pret.routing.Route","title":"<code>Route</code>","text":""},{"location":"reference/pret/routing/#pret.routing.BrowserRouter","title":"<code>BrowserRouter</code>","text":""},{"location":"reference/pret/routing/#pret.routing.HashRouter","title":"<code>HashRouter</code>","text":""},{"location":"reference/pret/routing/#pret.routing.Outlet","title":"<code>Outlet</code>","text":""},{"location":"reference/pret/routing/#pret.routing.use_location","title":"<code>use_location</code>","text":""},{"location":"reference/pret/routing/#pret.routing.use_match","title":"<code>use_match</code>","text":""},{"location":"reference/pret/routing/#pret.routing.use_params","title":"<code>use_params</code>","text":""},{"location":"reference/pret/routing/#pret.routing.use_search_params","title":"<code>use_search_params</code>","text":""},{"location":"reference/pret/serve/","title":"<code>pret.serve</code>","text":""},{"location":"reference/pret/store/","title":"<code>pret.store</code>","text":""},{"location":"reference/pret/store/#pret.store.AutoArray","title":"<code>AutoArray</code>","text":"<p>           Bases: <code>Array</code></p> <p>Array subclass to automatically convert assigned values to container types.</p>"},{"location":"reference/pret/store/#pret.store.AutoMap","title":"<code>AutoMap</code>","text":"<p>           Bases: <code>Map</code></p> <p>Map subclass to automatically convert assigned values to container types.</p>"},{"location":"reference/pret/store/#pret.store.AutoDoc","title":"<code>AutoDoc</code>","text":"<p>           Bases: <code>Doc</code></p> <p>Doc with root container values auto converted to AutoArray and AutoMap.</p>"},{"location":"reference/pret/store/#pret.store.AutoDoc.on_update","title":"<code>on_update</code>","text":"<p>Register a callback to be called on document updates.</p>"},{"location":"reference/pret/store/#pret.store.AutoDoc.to_py","title":"<code>to_py</code>","text":"<p>Convert the document to a Python dictionary.</p>"},{"location":"reference/pret/store/#pret.store.create_store","title":"<code>create_store</code>","text":"<p>Create a new store that can be used to store and synchronize data between various components of the app, between a server and its clients, or between different processes (or across multiple runs of the app) using a file.</p>"},{"location":"reference/pret/store/#pret.store.create_store--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>data</code> <p>Initial data to store in the document. It can be a dictionary, list, or any simple value.</p> <p> </p> <code>sync</code> <p>There are three options for this parameter:</p> <ul> <li>If false, this store will not be synchronized between a server and its   clients. This can be useful for local-only stores, like style management.</li> <li>If true, the store will be synchronized between a server and its clients.   Any changes made to the store will be sent to the server and vice versa.</li> <li>If a path is provided, the store will be synchronized with the file at this   path. Any changes made to the store will be written to the file, and any   changes made to the file will be read into the store. This can be useful   if you want to persist the store to disk or share it between different   processes (think servers or kernels).</li> </ul> <p> TYPE: <code>Optional[Union[bool, str, PathLike]]</code> DEFAULT: <code>None</code> </p>"},{"location":"reference/pret/store/#pret.store.subscribe","title":"<code>subscribe</code>","text":"<p>Subscribe to changes in a store.</p>"},{"location":"reference/pret/store/#pret.store.subscribe--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>store</code> <p>The store to subscribe to.</p> <p> TYPE: <code>Any</code> </p> <code>callback</code> <p>The function to call when the object changes.</p> <p> TYPE: <code>callable</code> DEFAULT: <code>None</code> </p> <code>notify_in_sync</code> <p>If True, the callback will be called in sync with the change. Only relevant in the browser environment.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>callable</code> <p>A function that can be used to unsubscribe from the changes.</p>"},{"location":"reference/pret/ui/react/","title":"<code>pret.ui.react</code>","text":"<p>Backward compatibility shim for the previous <code>pret.ui.react</code> import path.</p>"},{"location":"changelog/","title":"v0.5.1 (2025-11-26)","text":"<ul> <li>Fix <code>pret update-jupyter-config</code> to support venv and envs with no existing configs</li> <li>Better support for lambda functions marshaling</li> <li>New useImperativeHandle hook</li> <li>Support for remote refs, ie <code>useRef</code> called on the server/kernel, to interact with client-side components or assemble them without a controller component.</li> <li>Introduced to concept of \"Widget\"</li> <li>New option host in <code>run</code>, e.g., <code>run(app, ..., host='0.0.0.0')</code></li> </ul>"},{"location":"changelog/#v041-2025-08-21","title":"v0.4.1 (2025-08-21)","text":"<ul> <li>Added script to update jupyter config to let it know where to find the custom environment data files (including our js artifacts)</li> <li>Added routing support, and moved base assets to \"/assets\"</li> <li>Added a <code>names</code> option to <code>pret stub</code> to only generate stubs for specific js objects</li> </ul>"},{"location":"changelog/#v040-2025-08-19","title":"v0.4.0 (2025-08-19)","text":"<ul> <li>Drop valtio in favor of a YJS based shared state management, with a speedup up to 5x for mutations in large arrays.</li> <li>Fixed prepack command that didn't collect used js modules</li> </ul>"},{"location":"changelog/#v030-2025-07-01","title":"v0.3.0 (2025-07-01)","text":"<ul> <li>Add file system persistence for stores, using concatenations of yjs/pycrdt update binaries. Using file watchers, this also enables collaboration between multiple users using different servers/kernels.</li> <li>Renamed <code>proxy(..., remote_sync=...)</code> to <code>create_store(..., sync=...)</code> to better reflect the purpose of the function.</li> <li>Fixed front end to support large binary updates</li> </ul>"},{"location":"changelog/#v020-2025-06-10","title":"v0.2.0 (2025-06-10)","text":"<ul> <li> <p>Major change: I dropped pyodide and replaced it with Python \u2192 JavaScript transpilation (using Transcrypt) on the server. This comes with a few caveats such as the lack of support for some Python constructs and modules (to be documented), but brings a lot of benefits:</p> <ul> <li>Runtime performance: the runtime is now much faster, as it runs in JavaScript the browser and does not require a converting Python objects to JavaScript objects and back.</li> <li>First-time load: the first-time load is now much faster, as we don't require to load the Pyodide runtime and the Python standard library in the browser.</li> <li>Portability: pret can now run without Internet access, as it does not require to load the Pyodide.</li> <li>Error handling: errors (and any thrown object) are now bubbled outside Python and can be handled in JavaScript, which allows for better error handling, as well as throwing Promises to support React Suspense.</li> </ul> </li> <li> <p>Pret tracked proxies are now marshaled as valtio and proxies in the browser: it is no longer possible to mutate the state using the output of <code>use_store_snapshot</code>.</p> </li> <li>Dropped old custom valtio-like python state management, and use (pret-)pycrdt instead</li> <li>Added dependency to pret-pycrdt, fork of pycrdt to support identity preservation and therefore pickling, required for our marshaling mechanism</li> <li>Improved notebook-kernel pret manager synchronization and resynchronization</li> </ul>"},{"location":"changelog/#v010-2025-03-20-initial-release","title":"v0.1.0 (2025-03-20): Initial release","text":"<p>Pret is a library for building full-stack reactive user interfaces in Python, using React as a rendering engine.</p>"},{"location":"changelog/#installation","title":"Installation","text":"<pre><code>pip install pret pret-joy\n</code></pre>"},{"location":"changelog/#features","title":"Features","text":"<ul> <li>Python, only Python: pret is written in Python: you can write your both your UI and server actions Python. No need to learn a new language, or to use a transpiler.</li> <li>Client-side rendering: unlike other Python UI frameworks, pret runs primarily in the browser. This enables a fast response time to user actions (like hover events), and a better user experience under degraded network conditions.</li> <li>Built on React: pret uses React as a rendering engine, and benefits from its ecosystem.</li> <li>Reactive: unlike other solutions like ipywidgets, pret is reactive. Only the parts of the UI that need to be updated are re-rendered.</li> <li>State management: in addition to React's local state management (i.e. <code>use_state</code>), pret provides a global and modular state management solution that is synchronized both between components, and between the client and the server.</li> <li>Modular: pret is designed to be modular. You can easily create your own components, and reuse them in other pret-based projects.</li> <li>Integrated with Jupyter: pret components can be used in Jupyter notebooks, as well as in standalone web applications.</li> <li>Remote execution: pret can call and use the result of Python functions on the server from the browser</li> </ul>"}]}